<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//----------- Determine the time it takes to feed by doing an actual feed&#xD;
Calibrate_Trigger_R(Clk:=HMI_Calc_Data_Feed.Calibrate_Trigger);&#xD;
// Toggle between feed recording mode and not&#xD;
IF (Calibrate_Trigger_R.Q) THEN&#xD;
	HMI_Calc_Data_Feed.Calibrate_State := NOT HMI_Calc_Data_Feed.Calibrate_State;&#xD;
END_IF;&#xD;
IF (NOT HMI_Calc_Data_Feed.Page_Active) THEN&#xD;
	HMI_Calc_Data_Feed.Calibrate_State := FALSE;&#xD;
END_IF;&#xD;
&#xD;
// Communicate that calibration is active so that we use the values of auto when triggering a micro&#xD;
Feeder_Signals.Feed_Calc_Active := HMI_Calc_Data_Feed.Calibrate_State;&#xD;
&#xD;
// Setup rising edges&#xD;
Move_Busy_R(Clk:=Feeder_Signals.Micro_Feed_Busy);&#xD;
Move_Busy_F(Clk:=Feeder_Signals.Micro_Feed_Busy);&#xD;
&#xD;
IF (Move_Busy_R.Q) AND (HMI_Calc_Data_Feed.Calibrate_State) THEN&#xD;
	Move_Timing_Toggle := TRUE;&#xD;
END_IF;&#xD;
&#xD;
Move_Timer(In:=Move_Timing_Toggle, PT:=T#1d);&#xD;
&#xD;
// Record time when move is finished&#xD;
IF (Move_Busy_F.Q) THEN&#xD;
	HMI_Calc_Data_Feed.Feed_Rec_Time := (TO_REAL(Time_To_Ms(Move_Timer.ET)))/1000;&#xD;
	Move_Timing_Toggle := FALSE;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
//------------ Feed time estimation calculations&#xD;
// Calculate time needed to accelerate&#xD;
T_Accel := SafeDiv_LREAL(Feeder_Signals.Speed, Feeder_Signals.Accel);&#xD;
&#xD;
Accel_Calc(Enable:=TRUE,&#xD;
					Slope:=Feeder_Signals.Accel,&#xD;
					Phase_Time:=T_Accel);&#xD;
D_Acc := Accel_Calc.Distance;&#xD;
&#xD;
// Calculate time needed to decelerate&#xD;
T_Decel := SafeDiv_LREAL(Feeder_Signals.Speed, Feeder_Signals.Decel);&#xD;
&#xD;
Decel_Calc(Enable:=TRUE,&#xD;
		   			Slope:=Feeder_Signals.Decel,&#xD;
					Phase_Time:=T_Decel);&#xD;
D_Dec := Decel_Calc.Distance;&#xD;
&#xD;
// Distance remaining gets attributed to the constant velocity phase&#xD;
D_Rem := Feeder_Signals.Distance-D_Acc-D_Dec;&#xD;
&#xD;
// Determine Trapezoidal or Triangular motion profile&#xD;
Triangular := (D_Rem &lt;= 0);&#xD;
Trapezoidal := NOT Triangular;&#xD;
&#xD;
IF (Trapezoidal) THEN&#xD;
	// Time at constant velocity&#xD;
	T_Const := SafeDiv_LREAL(D_Rem, Feeder_Signals.Speed);&#xD;
ELSIF (Triangular) THEN&#xD;
	T_Const := 0;&#xD;
	&#xD;
	// Figure out the distance that will go into each phase (accel/decel)&#xD;
	Triangular_Accel_D :=Feeder_Signals.Distance*(SafeDiv_LREAL(Feeder_Signals.Decel, (Feeder_Signals.Accel+Feeder_Signals.Decel)));&#xD;
	Triangular_Decel_D :=Feeder_Signals.Distance*(SafeDiv_LREAL(Feeder_Signals.Accel, (Feeder_Signals.Accel+Feeder_Signals.Decel)));&#xD;
	&#xD;
	// Figure out the time necessary for accel and decel&#xD;
	T_Accel := SQRT(2*SafeDiv_LREAL(Triangular_Accel_D, Feeder_Signals.Accel));&#xD;
	T_Decel := SQRT(2*SafeDiv_LREAL(Triangular_Decel_D, Feeder_Signals.Decel));&#xD;
END_IF;&#xD;
&#xD;
T_Total := T_Accel + T_Decel + T_Const;&#xD;
&#xD;
HMI_Calc_Data_Feed.Estimated_Time := T_Total;&#xD;
&#xD;
//---------- Calculate time available for feeding&#xD;
IF (HMI_Feed_Pos1 &gt; HMI_Feed_Pos2) THEN&#xD;
	Available_CAM := 360-HMI_Feed_Pos1+HMI_Feed_Pos2;&#xD;
ELSE&#xD;
	Available_CAM := ABS(HMI_Feed_Pos1-HMI_Feed_Pos2);&#xD;
END_IF;&#xD;
&#xD;
// Convert SPM to Deg/S and estimate available time&#xD;
DPS :=Press_Signals.Press_Speed_SPM/60*360;&#xD;
HMI_Calc_Data_Feed.Cam_Available_Time := SafeDiv_LREAL(Available_CAM, DPS);&#xD;
&#xD;
// Determine cam necessary for feed time&#xD;
HMI_Calc_Data_Feed.Cam_Estimated := DPS*HMI_Calc_Data_Feed.Estimated_Time;&#xD;
HMI_Calc_Data_Feed.Cam_Necessary_Time_Rec_Time := DPS*HMI_Calc_Data_Feed.Feed_Rec_Time;&#xD;
&#xD;
//----------- Calculate actual linear position of press based on crankshaft angle&#xD;
Press_Distance_Real := TO_REAL(Convert_Deg_To_Height(Deg:=Press.Pos,&#xD;
													  Half_Stroke:=HMI_Calc_Data_Press_Retained.Stroke/2,&#xD;
													  Pitman_Length:=HMI_Calc_Data_Press_Retained.Pitman_Length));&#xD;
&#xD;
&#xD;
//------------ Press model determination&#xD;
&#xD;
HMI_Press_Model_Transfer_R(CLK := (HMI_Press_Model_Transfer) OR (P_First_Run));&#xD;
IF (HMI_Press_Model_Transfer_R.Q) THEN&#xD;
	HMI_Press_Data.Press_Type_Display.AZ1 := FALSE;&#xD;
	HMI_Press_Data.Press_Type_Display.AZ2 := FALSE;&#xD;
	HMI_Press_Data.Press_Type_Display.S := FALSE;&#xD;
	HMI_Press_Data.Press_Type_Display.AZS1 := FALSE;&#xD;
	HMI_Press_Data.Press_Type_Display.AZ_B1 := FALSE;&#xD;
	HMI_Press_Data.Press_Type_Display.AZ_B2 := FALSE;&#xD;
	HMI_Press_Data.Press_Type_Display.AZ_S1 := FALSE;&#xD;
	HMI_Press_Data.Press_Type_Display.AZ_S2 := FALSE;&#xD;
&#xD;
	CASE HMI_Data_Press_Retained.Press_Model OF&#xD;
		0,1,2,3,4,5,6,7,8,9,10,11,12: HMI_Press_Data.Press_Type_Display.AZ1 := TRUE;&#xD;
		13,14,15,16,17,18: HMI_Press_Data.Press_Type_Display.AZ2 := TRUE;&#xD;
		19,20,21,22,23,24,25: HMI_Press_Data.Press_Type_Display.S := TRUE;&#xD;
		26,27,28,29,30,31,32,33,34,35: HMI_Press_Data.Press_Type_Display.AZS1 := TRUE;&#xD;
		36: HMI_Press_Data.Press_Type_Display.AZ_B2 := TRUE;&#xD;
		//: HMI_Press_Data.Press_Type_Display.AZ_B1 := TRUE; *** NOT Determined YET ***&#xD;
		//: HMI_Press_Data.Press_Type_Display.AZ_S1 := TRUE; *** NOT Determined YET ***&#xD;
		//: HMI_Press_Data.Press_Type_Display.AZ_S2 := TRUE; *** NOT Determined YET ***&#xD;
	END_CASE;&#xD;
END_IF;&#xD;
&#xD;
//------------ Feeder model determination&#xD;
&#xD;
HMI_Feeder_Model_Transfer_R(CLK := (HMI_Feeder_Model_Transfer) OR (P_First_Run));&#xD;
IF (HMI_Feeder_Model_Transfer_R.Q) THEN&#xD;
	HMI_Feeder_Data.Feeder_Display_Model.AZ_F := FALSE;&#xD;
	HMI_Feeder_Data.Feeder_Display_Model.AZ_SF := FALSE;&#xD;
	HMI_Feeder_Data.Feeder_Display_Model.AZ_HSF := FALSE;&#xD;
	HMI_Feeder_Data.Feeder_Display_Model.AZ_MSF := FALSE;&#xD;
	HMI_Feeder_Data.Feeder_Display_Model.AZ_MF := FALSE;&#xD;
&#xD;
	CASE HMI_Feeder_Data_Retained.Feeder_Model OF&#xD;
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17: HMI_Feeder_Data.Feeder_Display_Model.AZ_F := TRUE;&#xD;
		36,37,38,39,40,41,42,43,44,45,46,47,48: HMI_Feeder_Data.Feeder_Display_Model.AZ_SF := TRUE;&#xD;
		18,19,20,21,22,23,24,25,26,27,28,29,30,31,32: HMI_Feeder_Data.Feeder_Display_Model.AZ_HSF := TRUE;&#xD;
		33,34,35: HMI_Feeder_Data.Feeder_Display_Model.AZ_MSF := TRUE;&#xD;
		49,50: HMI_Feeder_Data.Feeder_Display_Model.AZ_MF := TRUE;&#xD;
	END_CASE;&#xD;
END_IF;&#xD;
&#xD;
HMI_Uncoiler_Model_Transfer_R(CLK := (HMI_Uncoiler_Model_Transfer) OR (P_First_Run));&#xD;
IF (HMI_Feeder_Model_Transfer_R.Q) THEN&#xD;
	//------------ Uncoiler model determination&#xD;
	HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_D := FALSE;&#xD;
	HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_D2H := FALSE;&#xD;
	HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_DF := FALSE;&#xD;
	HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_DH := FALSE;&#xD;
	HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_DS := FALSE;&#xD;
	HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_HPD := FALSE;&#xD;
	HMI_Data_Uncoiler.Uncoiler_Display_Model.D := FALSE;&#xD;
&#xD;
	CASE HMI_Data_Uncoiler_Retained.Uncoiler_Model OF&#xD;
		0,1,2,3,4,5: HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_D := TRUE;&#xD;
		6,7,8,9: HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_D2H := TRUE;&#xD;
		10,11,12,13,14,15,16: HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_DF := TRUE;&#xD;
		17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42: HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_DH := TRUE;&#xD;
		43,44,45,46,47,48,49,50: HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_DS := TRUE;&#xD;
		51,52,53: HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_HPD := TRUE;&#xD;
		54,55,56,57: HMI_Data_Uncoiler.Uncoiler_Display_Model.D := TRUE;&#xD;
	END_CASE;&#xD;
END_IF;&#xD;
&#xD;
//------------ Feeder ratio calculation&#xD;
HMI_Feeder_Data_Retained.Feeder_Ratio := (HMI_Feeder_Data_Retained.Roller_Diameter*3.1415926535)/HMI_Feeder_Data_Retained.Reduction_Ratio;&#xD;
&#xD;
//------------ Counter Balance Suggested Air pressure Calculation&#xD;
IF (HMI_Press_Model_Transfer_R.Q) THEN&#xD;
	IF (HMI_Data_Press_Retained.Press_Model = 2) THEN // AZ1-60&#xD;
		m := 0.026075566;&#xD;
		b := 34;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 34;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 1488.120525;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 73;&#xD;
		&#xD;
	ELSIF (HMI_Data_Press_Retained.Press_Model = 3)THEN // AZ1-80&#xD;
		m := 0.02761014476;&#xD;
		b := 38;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 38;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 1267.658225;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 73;&#xD;
			&#xD;
	ELSIF (HMI_Data_Press_Retained.Press_Model = 4 OR HMI_Data_Press_Retained.Press_Model = 5 OR HMI_Data_Press_Retained.Press_Model = 6 OR HMI_Data_Press_Retained.Press_Model = 7) THEN // AZ1-100, AZ1-110, AZ1-120, AZ1-140&#xD;
		m := 0.02429958708;&#xD;
		b := 51;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 51;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 617.29444;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 66;&#xD;
		&#xD;
	ELSIF (HMI_Data_Press_Retained.Press_Model = 8) THEN // AZ1-175&#xD;
		m := 0.0147417495;&#xD;
		b := 61;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 61;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 881.8492;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 74;&#xD;
&#xD;
	ELSIF (HMI_Data_Press_Retained.Press_Model = 9) THEN // AZ1-220&#xD;
		m := 0.01209579446;&#xD;
		b := 57;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 57;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 1322.7738;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 73;&#xD;
		&#xD;
	ELSIF (HMI_Data_Press_Retained.Press_Model = 10 OR HMI_Data_Press_Retained.Press_Model =11) THEN // AZ1-275, AZ1-340&#xD;
		m := 0.0113398073;&#xD;
		b := 53;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 53;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 1763.6894;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 73;&#xD;
		&#xD;
	ELSIF (HMI_Data_Press_Retained.Press_Model = 13 OR HMI_Data_Press_Retained.Press_Model = 14) THEN // AZ2-80, AZ2-120&#xD;
		m := 0.006047897229;&#xD;
		b := 53;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 53;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 1322.7738;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 61;&#xD;
		&#xD;
	ELSIF (HMI_Data_Press_Retained.Press_Model = 15) THEN // AZ2-175&#xD;
		m := 0.009827832998;&#xD;
		b := 48;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 48;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 1322.7738;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 61;&#xD;
		&#xD;
	ELSIF (HMI_Data_Press_Retained.Press_Model = 16) THEN // AZ2-220&#xD;
		m := 0.005443107506;&#xD;
		b := 47;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 47;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 2204.623;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 59;&#xD;
&#xD;
	ELSIF (HMI_Data_Press_Retained.Press_Model = 17) THEN // AZ2-275&#xD;
		m := 0.004157929345;&#xD;
		b := 50;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 50;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 2645.5476;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 61;&#xD;
		&#xD;
&#xD;
	ELSE // Press that we do not have the Data for this calculation yet&#xD;
		m := 0.0;&#xD;
		b := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_1.Y := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.X := 0;&#xD;
		HMI_Calc_Data_Press.Graph_Pos_2.Y := 0;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
// Determine if a straightner is present&#xD;
Master_Features.Straightner := HMI_Feeder_Data.Feeder_Display_Model.AZ_HSF OR HMI_Feeder_Data.Feeder_Display_Model.AZ_MSF OR&#xD;
												  HMI_Feeder_Data.Feeder_Display_Model.AZ_SF OR HMI_Data_Uncoiler.Uncoiler_Display_Model.AZ_DS;&#xD;
&#xD;
  &#xD;
HMI_Calc_Data_Press.Suggested_Air_Pressure:= m*(HMI_Calc_Data_Press.Upper_Die_Weight)+b;  // Sugested Air Pressure formula&#xD;
// Setting up Chart Data&#xD;
HMI_Calc_Data_Press.Chart_Data[0] := 2.0;        // Number of points&#xD;
HMI_Calc_Data_Press.Chart_Data[1] := HMI_Calc_Data_Press.Graph_Pos_1.X;	// X1&#xD;
HMI_Calc_Data_Press.Chart_Data[2] := HMI_Calc_Data_Press.Graph_Pos_1.Y;	// Y1&#xD;
HMI_Calc_Data_Press.Chart_Data[3] := HMI_Calc_Data_Press.Graph_Pos_2.X;	// X2&#xD;
HMI_Calc_Data_Press.Chart_Data[4] := HMI_Calc_Data_Press.Graph_Pos_2.Y;	// Y2&#xD;
&#xD;
// ---------- Tooling sharpening counter&#xD;
BDC_Zone(Enable := TRUE, Pos := Press.Pos, Angle1 := 170, Angle2 := 190);&#xD;
BDC_Zone_R(Clk := BDC_Zone.In_Zone);&#xD;
Reset_Sharpening_CT_R(Clk := HMI_Die_Config.Reset_Sharpening_CT);&#xD;
&#xD;
IF (Recipe_Number &lt; SizeOfAry(Sharpening_Data)) THEN&#xD;
	// Increment current punch&#xD;
	IF (BDC_Zone_R.Q) THEN&#xD;
		Sharpening_Data[Recipe_Number] := Sharpening_Data[Recipe_Number]+1;&#xD;
	END_IF;&#xD;
	&#xD;
	// Reset sharpening counter when demanded&#xD;
	IF (Reset_Sharpening_CT_R.Q) THEN&#xD;
		Sharpening_Data[Recipe_Number] := 0;&#xD;
		// Record date when reset&#xD;
	 	DtToDateStruct(In := GetTime(), DateStruct =&gt; Current_Time_DT);&#xD;
		HMI_Die_Config.Last_Sharpening_Day := USINT_TO_INT(Current_Time_DT.Day);&#xD;
		HMI_Die_Config.Last_Sharpening_Month := USINT_TO_INT(Current_Time_DT.Month);&#xD;
		HMI_Die_Config.Last_Sharpening_Year := UINT_TO_INT(Current_Time_DT.Year);&#xD;
	END_IF;&#xD;
	&#xD;
	// Display data for current punch&#xD;
	HMI_Die_Config.Punch_Since_Last_Sharpening := Sharpening_Data[Recipe_Number];&#xD;
	// Display punches left until sharpening setpoint&#xD;
	IF ((HMI_Die_Config.Punch_Sharpening_SP&gt;=HMI_Die_Config.Punch_Since_Last_Sharpening)) THEN&#xD;
		HMI_Die_Config.Punch_Left_Until_Sharpening := ABS(HMI_Die_Config.Punch_Sharpening_SP-HMI_Die_Config.Punch_Since_Last_Sharpening);&#xD;
	END_IF;&#xD;
	&#xD;
	// If we are due for a sharpening then trigger a warning&#xD;
	IF (HMI_Die_Config.Punch_Since_Last_Sharpening &gt;= HMI_Die_Config.Punch_Sharpening_SP) AND&#xD;
		(NOT HMI_Press_Data.BP_Sharpening_Alarm) AND (HMI_Die_Config.Punch_Sharpening_SP&gt;0) THEN&#xD;
		HMI_Press_Data.Alarms.Die_Sharpening_Warning := TRUE;&#xD;
	ELSE&#xD;
		HMI_Press_Data.Alarms.Die_Sharpening_Warning := FALSE;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
// ---------- Operation mode saving&#xD;
// Record palm or pedal&#xD;
IF (HMI_Press_Data.Palm_Activated_FB) THEN&#xD;
	ResetABit(HMI_C_Press_Misc_Data.Mode_Operation, 0);&#xD;
ELSIF (HMI_Press_Data.Pedal_Activated_FB) THEN&#xD;
	SetABit(HMI_C_Press_Misc_Data.Mode_Operation, 0);&#xD;
END_IF;&#xD;
&#xD;
// Record Single or Auto&#xD;
IF (Act_Mode_Single) THEN&#xD;
	ResetABit(HMI_C_Press_Misc_Data.Mode_Operation, 1);&#xD;
ELSIF (Act_Mode_Auto) THEN&#xD;
	SetABit(HMI_C_Press_Misc_Data.Mode_Operation, 1);&#xD;
END_IF;&#xD;
&#xD;
// Record Automatic Single Stroke&#xD;
IF (HMI_Data_Press_Retained.Automatic_Single_Stroke_Active) THEN&#xD;
	SetABit(HMI_C_Press_Misc_Data.Mode_Operation, 2);&#xD;
ELSE&#xD;
	ResetABit(HMI_C_Press_Misc_Data.Mode_Operation, 2);&#xD;
END_IF;&#xD;
&#xD;
IF (HMI_Data_Press_Retained.Automatic_Stroke_Feeder_Active) THEN&#xD;
	SetABit(HMI_C_Press_Misc_Data.Mode_Operation, 3);&#xD;
ELSE&#xD;
	ResetABit(HMI_C_Press_Misc_Data.Mode_Operation, 3);&#xD;
END_IF;&#xD;
&#xD;
IF (HMI_Data_Press_Retained.Continuous_On_Demand_Active) THEN&#xD;
	SetABit(HMI_C_Press_Misc_Data.Mode_Operation, 4);&#xD;
ELSE&#xD;
	ResetABit(HMI_C_Press_Misc_Data.Mode_Operation, 4);&#xD;
END_IF;&#xD;
&#xD;
IF (HMI_Press_Data.Mode_Cut_To_Lenght_Toggle) THEN&#xD;
	SetABit(HMI_C_Press_Misc_Data.Mode_Operation, 5);&#xD;
ELSE&#xD;
	ResetABit(HMI_C_Press_Misc_Data.Mode_Operation, 5);&#xD;
END_IF;&#xD;
&#xD;
IF (HMI_C_Press_Misc_Data.Mode_Operation &lt;&gt; HMI_C_Press_Misc_Data.Mode_Operation_Saved) THEN&#xD;
	HMI_C_Press_Misc_Data.Warning_Mode_Operation := TRUE;&#xD;
ELSE&#xD;
	HMI_C_Press_Misc_Data.Warning_Mode_Operation := FALSE;&#xD;
END_IF;&#xD;
&#xD;
HMI_C_Press_Misc_Data.Msg_Mode_Operation := Operating_Mode_Msg(HMI_C_Press_Misc_Data.Mode_Operation_Saved);&#xD;
&#xD;
Save_Mode_Operation_R(Clk := HMI_C_Press_Misc_Data.Save_Mode_Operation);&#xD;
IF (Save_Mode_Operation_R.Q) THEN&#xD;
	HMI_C_Press_Misc_Data.Mode_Operation_Saved := HMI_C_Press_Misc_Data.Mode_Operation;&#xD;
END_IF;</Text></StructuredTextModel>