{"CLs":[{"__type":"IST","EID":"7d3970dc-6ae2-47bd-8cb9-0d21ffc17718","H":132,"TXT":"\/\/ Modulo between the distance of the Gag Origin and the shear by the Part Lenght\u000d\u000aModulo_Shear_Dist_Gag_OG := ModReal(HMI_ABS_Seq_Data.Dist_Origin_to_Shear,HMI_ABS_Seq_Data.Part_Lenght);\u000d\u000a\u000d\u000a","W":1151}],"CMT":"Caculation for internal variable","LRI":1,"RRI":2,"VLs":[]}
{"CLs":[{"__type":"LD","Var":"HMI_ABS_Seq_Data.Calulate_Positions_Button"},{"__type":"IST","EID":"0df96e33-68ae-4dac-8f7b-e4ee60520e6f","H":786.99999999999989,"Ix":1,"TXT":"\u000d\u000aFOR H := 0 To 29 BY 1 DO\u000d\u000a\u0009Seq_Absolute_Input[H].Feed :=\u0009HMI_ABS_Seq_Data.Feed[H];\u000d\u000a\u0009Seq_Absolute_Input[H].Punch := HMI_ABS_Seq_Data.Punch[H];\u000d\u000aEND_FOR;\u000d\u000a\u000d\u000a\u000d\u000a\/\/Offset the Feeding positions according to the position of the punches in the die.\u000d\u000aFOR I := 0 TO 29 BY 1 DO\u000d\u000a\u0009FOR J := 0 TO 16 BY 1 DO\u000d\u000a\u0009\u0009IF (Seq_Absolute_Input[I].Punch = J) AND\u000d\u000a\u0009\u0009\u0009 (Seq_Absolute_Input[I].Punch < 16) THEN\u000d\u000a\u0009\u0009\u0009Offset_Pos[I].Feed := HMI_ABS_Seq_Data.Gag_Pos[J]+Seq_Absolute_Input[I].Feed-Modulo_Shear_Dist_Gag_OG;\u000d\u000a\u0009\u0009ELSIF (Seq_Absolute_Input[I].Punch < 1 AND Seq_Absolute_Input[I].Feed = 0)THEN\u000d\u000a\u0009\u0009\u0009Offset_Pos[I].Feed := 0;\u000d\u000a\u0009\u0009END_IF;\u000d\u000a\u0009\u0009Offset_Pos[I].Punch := Seq_Absolute_Input[I].Punch;\u000d\u000a\u0009END_FOR;\u000d\u000a\u0009\u000d\u000a\u0009IF (Seq_Absolute_Input[I].Punch = 16)THEN\u000d\u000a\u0009Offset_Pos[I].Feed := HMI_ABS_Seq_Data.Part_Lenght;\u000d\u000a\u0009END_IF;\u000d\u000aEND_FOR;\u000d\u000a\u000d\u000a\/\/Put the Feed distance back in the part lenght range.\u000d\u000aFOR K := 0 TO 29 BY 1 DO\u000d\u000a\u0009IF ( HMI_ABS_Seq_Data.Part_Lenght < Offset_Pos[K].Feed  AND Offset_Pos[K].Feed>0)THEN\u000d\u000a\u0009\u0009In_Range_Pos[K].Feed := Offset_Pos[K].Feed - Seq_Absolute_Input[K].Feed;\u000d\u000a\u0009ELSIF (Offset_Pos[K].Feed < 0) THEN\u000d\u000a\u0009\u0009In_Range_Pos[K].Feed := Offset_Pos[K].Feed + HMI_ABS_Seq_Data.Part_Lenght;\u000d\u000a\u0009ELSIF( 0<= Offset_Pos[K].Feed AND Offset_Pos[K].Feed<=HMI_ABS_Seq_Data.Part_Lenght)THEN\u000d\u000a\u0009\u0009In_Range_Pos[K].Feed := Offset_Pos[K].Feed;\u000d\u000a\u0009END_IF;\u000d\u000a\u0009\u000d\u000a\u0009In_Range_Pos[K].Punch := Offset_Pos[K].Punch;\u000d\u000aEND_FOR;\u000d\u000a","W":1363,"X":1}],"CMT":"Offset the position according to gag positions in the die, and put them back in the range of the part lenght","LRI":2,"RRI":3,"VLs":[]}
{"CLs":[{"__type":"LD","Var":"HMI_ABS_Seq_Data.Calulate_Positions_Button"},{"__type":"FB","In":[{"__type":"PF","Arg":"Enable"},{"__type":"PRM","Arg":"Feed_Array","Ix":1,"Type":"ARRAY[0..30] OF LREAL","Var":""},{"__type":"PRM","Arg":"Punch_Array","Ix":2,"Type":"ARRAY[0..30] OF INT","Var":""},{"__type":"PRM","Arg":"InSequence","Ix":3,"Type":"ARRAY[0..30] OF Sequence_Absolute","Var":"In_Range_Pos"},{"__type":"PRM","Arg":"Size","Ix":4,"Type":"INT","Var":"Size"}],"Ix":6,"Name":"Sort_Feed","Out":[{"__type":"PRM","Arg":"OutSequence","Ix":5,"Type":"ARRAY[0..30] OF Sequence_Absolute","Var":"Sorted_Pos"},{"__type":"PF","Arg":"Done"}],"UD":true,"X":1,"Var":"Sequence_Absolute_Pos_Sorting_Feed"}],"CMT":"Sort the IN range positions so we go from smallest to largest","LRI":7,"RRI":8,"VLs":[]}
{"CLs":[{"__type":"LD","Var":"HMI_ABS_Seq_Data.Calulate_Positions_Button"},{"__type":"IST","EID":"69e76b09-4abf-4e2e-b8cc-e768c00038e1","H":1436,"Ix":1,"TXT":"\/\/ Transfer the Absolute position into incremental lenght for the Feed.\u000d\u000aFind_Last_Instance_1(Enable := Reset_Iterator_R.Q, Sequence := Sorted_Pos, Last => Last_1);\u000d\u000aReset_Iterator_R(Clk:=Sequence_Absolute_Pos_Sorting_Feed.Done);\u000d\u000aIF (Reset_Iterator_R.Q) THEN\u000d\u000a\u0009Itterator := 0;\u000d\u000a\u0009FOR L := 1 TO 29 BY 1 DO\u000d\u000a\u0009\u0009Incremental_Pos[L].Feed := 0 ;\u000d\u000a\u0009\u0009Incremental_Pos[L].Punch := 0;\u000d\u000a\u0009END_FOR;\u000d\u000aEND_IF;\u000d\u000a\u000d\u000a\u000d\u000a\u000d\u000a\u000d\u000aIncremental_Trigger_TON(In:=Reset_Iterator_R.Q, PT:=T#0.1s);\u000d\u000a\u000d\u000aIF(Itterator <1 AND NOT Incremental_Trigger_TON.Q ) THEN\u000d\u000a\u0009Incremental_Pos[0].Feed:= Sorted_Pos[0].Feed;\u000d\u000a\u0009Incremental_Pos[0].Punch := Sorted_Pos[0].Punch;\u000d\u000a\u0009\u000d\u000a\u0009FOR M := 1 TO Last_1 BY 1 DO\u000d\u000a\u0009\u0009Incremental_Pos[M].Feed := Sorted_Pos[M].Feed - Sorted_Pos[M-1].Feed ;\u000d\u000a\u0009\u0009Incremental_Pos[M].Punch := Sorted_Pos[M].Punch;\u000d\u000a\u0009END_FOR;\u000d\u000a\u0009Itterator := Itterator + 1;\u000d\u000aEND_IF;\u000d\u000a\u000d\u000a\u000d\u000a\/\/ find last element\u000d\u000aFind_Last_Instance(Reset_Iterator_R.Q, Incremental_Pos, Last);\u000d\u000aLast_Gag:=Incremental_Pos[Last].Punch;\u000d\u000a\u000d\u000a\u000d\u000aFOR N:=1 To Last BY 1 DO\u000d\u000a\u0009Incremental_Punch_Shift[N].Punch:= Incremental_Pos[N-1].Punch;\u000d\u000a\u0009Incremental_Punch_Shift[N].Feed := Incremental_Pos[N].Feed;\u000d\u000aEND_FOR;\u000d\u000a\u0009Incremental_Punch_Shift[0].Punch := Last_Gag;\u000d\u000a\u0009Incremental_Punch_Shift[0].Feed := Incremental_Pos[0].Feed;\u000d\u000a\u000d\u000a\u000d\u000a\u000d\u000a\u000d\u000a\u000d\u000aIF (Incremental_Punch_Shift[0].Punch = 16) THEN\u000d\u000a\u0009TempGag := Incremental_Punch_Shift[0].Punch;\u000d\u000a\u0009TempFeed := Incremental_Punch_Shift[0].Feed;\u000d\u000a\u0009ArySHR(InOut:=Incremental_Punch_Shift[0], Size:=Size, Num:=1);\u000d\u000a\u0009\/\/Incremental_Punch_Shift[0].Punch = Incremental_Punch_Shift[Last].Punch\u000d\u000a\u0009\/\/Incremental_Punch_Shift[0].Feed = InSequence.Gag[Last]\u000d\u000a\u0009Incremental_Punch_Shift[Last].Punch := TempGag;\u000d\u000a\u0009Incremental_Punch_Shift[Last].Feed := TempFeed;\u000d\u000aEND_IF;\u000d\u000a\u000d\u000a\/\/ Special logic for Steelway:\u000d\u000aFOR R:=1 To 29 BY 1 DO\u000d\u000a\u0009IF(Incremental_Punch_Shift[0].Punch = R) AND (Incremental_Punch_Shift[Last].Punch = 16) THEN\u000d\u000a\u0009\u0009Incremental_Punch_Shift[Last].Punch := (R*100)+16;\u000d\u000a\u0009END_IF;\u000d\u000aEND_FOR;\u000d\u000a\u000d\u000a","W":1118,"X":1}],"LRI":2,"RRI":3,"VLs":[]}
{"CLs":[{"__type":"LD","Var":"HMI_ABS_Seq_Data.Transfer_To_Active_Sequence"},{"__type":"IST","EID":"e185d729-a43c-47cc-84a4-4ebf661b4496","H":389,"Ix":1,"TXT":"\/\/ Enable the Sequences that will be used\u000d\u000a\u000d\u000aFOR P := 0 TO 29 BY 1 DO\u000d\u000a\u0009IF (Last >= P)THEN\u000d\u000a\u0009\u0009HMI_Feeder_Sequences_Retained.Enabled[P] := TRUE;\u000d\u000a\u0009ELSIF (Last < P)THEN\u000d\u000a\u0009\u0009HMI_Feeder_Sequences_Retained.Enabled[P] := FALSE;\u000d\u000a\u0009END_IF;\u000d\u000aEND_FOR;\u000d\u000a\u000d\u000a\/\/ Put the Data into the incremental sequences.\u000d\u000a\u000d\u000aFOR Q := 0 To 29 BY 1 DO\u000d\u000a\u0009HMI_Feeder_Sequences_Retained.Distance[Q] := LREAL_TO_REAL(Incremental_Punch_Shift[Q].Feed);\u000d\u000a\u0009HMI_Feeder_Sequences_Retained.Gag[Q] := Incremental_Punch_Shift[Q].Punch;\u000d\u000aEND_FOR;\u000d\u000a","W":846,"X":1}],"CMT":"When pressed, transfo the values into the active sequence","LRI":2,"RRI":3,"VLs":[]}
