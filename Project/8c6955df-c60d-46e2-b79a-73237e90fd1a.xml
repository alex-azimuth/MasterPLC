<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>Status := State &gt; 20;&#xD;
IF Enable THEN&#xD;
	UpdateRateTimer := ADD_TIME(UpdateRateTimer, GetMyTaskInterval());&#xD;
END_IF;&#xD;
&#xD;
IF State = 0 THEN&#xD;
	RequestCycleDone := FALSE;&#xD;
	Error := FALSE;&#xD;
	ErrorID := 0;&#xD;
	ErrorIDEx := 0;&#xD;
	ErrorRequestNO := 0;&#xD;
	IF Enable THEN&#xD;
		State := 10;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 10 THEN&#xD;
	iSktTCPConnect(Execute := FALSE, SrcTcpPort := 0, DstAdr := IPAddress, DstTcpPort := PortNo, Socket =&gt; Socket);&#xD;
	State := 20;&#xD;
END_IF;&#xD;
&#xD;
IF State = 20 THEN&#xD;
	iSktTCPConnect(Execute := TRUE, SrcTcpPort := 0, DstAdr := IPAddress, DstTcpPort := PortNo, Socket =&gt; Socket);&#xD;
	IF NOT iSktTCPConnect.Busy THEN&#xD;
		IF iSktTCPConnect.Done THEN&#xD;
			State := 30;&#xD;
		END_IF;&#xD;
		&#xD;
		IF iSktTCPConnect.Error THEN&#xD;
			ErrorID := iSktTCPConnect.ErrorID;&#xD;
			CloseSocket := TRUE;&#xD;
			State := 2000;&#xD;
		END_IF;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 30 THEN&#xD;
	iSktGetTCPStatus(Execute := FALSE, Socket := Socket);&#xD;
	State := 40;&#xD;
END_IF;&#xD;
&#xD;
IF State = 40 THEN&#xD;
	iSktGetTCPStatus(Execute := TRUE, Socket := Socket);&#xD;
	IF NOT iSktGetTCPStatus.Busy THEN&#xD;
		IF iSktGetTCPStatus.Done THEN&#xD;
			IF iSktGetTCPStatus.TcpStatus = _ESTABLISHED THEN&#xD;
				State := 50;&#xD;
			ELSE&#xD;
				CloseSocket := TRUE;&#xD;
				State := 2010; //Close socket without error&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		&#xD;
		IF iSktGetTCPStatus.Error THEN&#xD;
			ErrorID := iSktGetTCPStatus.ErrorID;&#xD;
			CloseSocket := TRUE;&#xD;
			State := 2000;&#xD;
		END_IF;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
// husk å differensiere på Close socket ved error State = 2000 (Kanskje lage ein ny state for error uten å close socket)&#xD;
&#xD;
&#xD;
IF State = 50 THEN	&#xD;
	IF Enable THEN&#xD;
		IF UpdateRateTimer &gt;= UpdateRate THEN&#xD;
			RequestPnt := LOWER_BOUND(Requests, 1);&#xD;
			UpdateRateTimer := T#0s;&#xD;
			RequestCycleStart := Get1msCnt();&#xD;
			TimeOut := LINT_TO_UINT(TimeToNanoSec(NodeTimeOut)/100000000); //Time to 0.1s&#xD;
			Error := FALSE;&#xD;
			ErrorRequestNO := 0;&#xD;
			ErrorID := 0;&#xD;
			ErrorIDEx := 0;&#xD;
			State := 60;&#xD;
		END_IF;&#xD;
	ELSE&#xD;
		CloseSocket := TRUE;&#xD;
		State := 2010; //Close socket without error&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 60 THEN&#xD;
	IF Enable THEN&#xD;
		FoundRequest := FALSE;&#xD;
		FOR i := RequestPnt TO UPPER_BOUND(Requests, 1) DO&#xD;
			IF Requests[i].Enable THEN&#xD;
				RequestPnt := i;&#xD;
				FoundRequest := TRUE;&#xD;
				EXIT;&#xD;
			END_IF;&#xD;
		END_FOR;&#xD;
		IF FoundRequest THEN&#xD;
			State := 70;&#xD;
		ELSE&#xD;
			State := 3000; //Finished&#xD;
		END_IF;&#xD;
	ELSE&#xD;
		CloseSocket := TRUE;&#xD;
		State := 2010; //Close socket without error&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 70 THEN&#xD;
	iSktClearBuf(Execute := FALSE, Socket := Socket);&#xD;
	State := 80;&#xD;
END_IF;&#xD;
&#xD;
IF State = 80 THEN&#xD;
	iSktClearBuf(Execute := FALSE, Socket := Socket);&#xD;
	IF NOT iSktClearBuf.Busy THEN&#xD;
		State := 100;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 100 THEN&#xD;
	Clear(SendAr);&#xD;
	Inc(TransactionID);&#xD;
	CASE Requests[RequestPnt].FunctionCode OF&#xD;
		eFun#Fn01_ReadCoils:							IF UINT_TO_DINT(Requests[RequestPnt].Read.StartAddressLocal) &gt;= LOWER_BOUND(Coils, 1) AND UINT_TO_DINT(Requests[RequestPnt].Read.StartAddressLocal + Requests[RequestPnt].Read.Count - 1)  &lt;= UPPER_BOUND(Coils, 1) THEN&#xD;
																		State := DINT_TO_UINT(100 + EnumToNum(Requests[RequestPnt].FunctionCode));&#xD;
																		&#xD;
																		ToAryByte(TransactionID, _HIGH_LOW, SendAr[0]);&#xD;
																		SendAr[2] := 16#00;&#xD;
																		SendAr[3] := 16#00;&#xD;
																		SendAr[6] := UINT_TO_BYTE(Requests[RequestPnt].NodeAdr);&#xD;
																		SendAr[7] := DINT_TO_BYTE(Requests[RequestPnt].FunctionCode);&#xD;
																		ToAryByte(Requests[RequestPnt].Read.StartAddressRemote, _HIGH_LOW, SendAr[8]);&#xD;
																		ToAryByte(Requests[RequestPnt].Read.Count, _HIGH_LOW, SendAr[10]);&#xD;
																		&#xD;
																		BytesInMessage := 6;	//Number bytes after the MBAP Header&#xD;
																		ToAryByte(BytesInMessage, _HIGH_LOW, SendAr[4]);&#xD;
																		PacketSize := 12;&#xD;
																		State := 110;&#xD;
																	ELSE&#xD;
																		//Address error&#xD;
																		ErrorRequestNO := RequestPnt;&#xD;
																		ErrorID := 16#1001; //Modbus address outside of Array boundary&#xD;
																		State := 2000;&#xD;
																	END_IF;&#xD;
																	&#xD;
		eFun#Fn02_ReadDiscreteInputs:			IF UINT_TO_DINT(Requests[RequestPnt].Read.StartAddressLocal) &gt;= LOWER_BOUND(DiscreteInputs, 1) AND UINT_TO_DINT(Requests[RequestPnt].Read.StartAddressLocal + Requests[RequestPnt].Read.Count - 1)  &lt;= UPPER_BOUND(DiscreteInputs, 1) THEN&#xD;
																		State := DINT_TO_UINT(100 + EnumToNum(Requests[RequestPnt].FunctionCode));&#xD;
																		&#xD;
																		ToAryByte(TransactionID, _HIGH_LOW, SendAr[0]);&#xD;
																		SendAr[2] := 16#00;&#xD;
																		SendAr[3] := 16#00;&#xD;
																		SendAr[6] := UINT_TO_BYTE(Requests[RequestPnt].NodeAdr);&#xD;
																		SendAr[7] := DINT_TO_BYTE(Requests[RequestPnt].FunctionCode);&#xD;
																		ToAryByte(Requests[RequestPnt].Read.StartAddressRemote, _HIGH_LOW, SendAr[8]);&#xD;
																		ToAryByte(Requests[RequestPnt].Read.Count, _HIGH_LOW, SendAr[10]);&#xD;
																		&#xD;
																		BytesInMessage := 6;	//Number bytes after the MBAP Header&#xD;
																		ToAryByte(BytesInMessage, _HIGH_LOW, SendAr[4]);&#xD;
																		PacketSize := 12;&#xD;
																		State := 110;&#xD;
																	ELSE&#xD;
																		//Address error&#xD;
																		ErrorRequestNO := RequestPnt;&#xD;
																		ErrorID := 16#1001; //Modbus address outside of Array boundary&#xD;
																		State := 2000;&#xD;
																	END_IF;&#xD;
		&#xD;
		eFun#Fn03_ReadHoldingRegisters:		IF UINT_TO_DINT(Requests[RequestPnt].Read.StartAddressLocal) &gt;= LOWER_BOUND(HoldingRegisters, 1) AND UINT_TO_DINT(Requests[RequestPnt].Read.StartAddressLocal + Requests[RequestPnt].Read.Count - 1)  &lt;= UPPER_BOUND(HoldingRegisters, 1) THEN&#xD;
																		State := DINT_TO_UINT(100 + EnumToNum(Requests[RequestPnt].FunctionCode));&#xD;
																		&#xD;
																		ToAryByte(TransactionID, _HIGH_LOW, SendAr[0]);&#xD;
																		SendAr[2] := 16#00;&#xD;
																		SendAr[3] := 16#00;&#xD;
																		SendAr[6] := UINT_TO_BYTE(Requests[RequestPnt].NodeAdr);&#xD;
																		SendAr[7] := DINT_TO_BYTE(Requests[RequestPnt].FunctionCode);&#xD;
																		ToAryByte(Requests[RequestPnt].Read.StartAddressRemote, _HIGH_LOW, SendAr[8]);&#xD;
																		ToAryByte(Requests[RequestPnt].Read.Count, _HIGH_LOW, SendAr[10]);&#xD;
																		&#xD;
																		BytesInMessage := 6;	//Number bytes after the MBAP Header&#xD;
																		ToAryByte(BytesInMessage, _HIGH_LOW, SendAr[4]);&#xD;
																		PacketSize := 12;&#xD;
																		State := 110;&#xD;
																	ELSE&#xD;
																		//Address error&#xD;
																		ErrorRequestNO := RequestPnt;&#xD;
																		ErrorID := 16#1001; //Modbus address outside of Array boundary&#xD;
																		State := 2000;&#xD;
																	END_IF;&#xD;
		&#xD;
		eFun#Fn04_ReadInputRegisters:			IF UINT_TO_DINT(Requests[RequestPnt].Read.StartAddressLocal) &gt;= LOWER_BOUND(InputRegisters, 1) AND UINT_TO_DINT(Requests[RequestPnt].Read.StartAddressLocal + Requests[RequestPnt].Read.Count - 1)  &lt;= UPPER_BOUND(InputRegisters, 1) THEN&#xD;
																		State := DINT_TO_UINT(100 + EnumToNum(Requests[RequestPnt].FunctionCode));&#xD;
																		&#xD;
																		ToAryByte(TransactionID, _HIGH_LOW, SendAr[0]);&#xD;
																		SendAr[2] := 16#00;&#xD;
																		SendAr[3] := 16#00;&#xD;
																		SendAr[6] := UINT_TO_BYTE(Requests[RequestPnt].NodeAdr);&#xD;
																		SendAr[7] := DINT_TO_BYTE(Requests[RequestPnt].FunctionCode);&#xD;
																		ToAryByte(Requests[RequestPnt].Read.StartAddressRemote, _HIGH_LOW, SendAr[8]);&#xD;
																		ToAryByte(Requests[RequestPnt].Read.Count, _HIGH_LOW, SendAr[10]);&#xD;
																		&#xD;
																		BytesInMessage := 6;	//Number bytes after the MBAP Header&#xD;
																		ToAryByte(BytesInMessage, _HIGH_LOW, SendAr[4]);&#xD;
																		PacketSize := 12;&#xD;
																		State := 110;&#xD;
																	ELSE&#xD;
																		//Address error&#xD;
																		ErrorRequestNO := RequestPnt;&#xD;
																		ErrorID := 16#1001; //Modbus address outside of Array boundary&#xD;
																		State := 2000;&#xD;
																	END_IF;&#xD;
																	&#xD;
		eFun#Fn05_WriteSingleCoil:				IF UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal) &gt;= LOWER_BOUND(Coils, 1) AND UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal)  &lt;= UPPER_BOUND(Coils, 1) THEN&#xD;
																		State := DINT_TO_UINT(100 + EnumToNum(Requests[RequestPnt].FunctionCode));&#xD;
&#xD;
																		ToAryByte(TransactionID, _HIGH_LOW, SendAr[0]);&#xD;
																		SendAr[2] := 16#00;&#xD;
																		SendAr[3] := 16#00;&#xD;
																		SendAr[6] := UINT_TO_BYTE(Requests[RequestPnt].NodeAdr);&#xD;
																		SendAr[7] := DINT_TO_BYTE(Requests[RequestPnt].FunctionCode);&#xD;
																		ToAryByte(Requests[RequestPnt].Write.StartAddressRemote, _HIGH_LOW, SendAr[8]);&#xD;
																		IF Coils[Requests[RequestPnt].Write.StartAddressLocal] THEN&#xD;
																			SendAr[10] := 16#FF;&#xD;
																		ELSE&#xD;
																			SendAr[10] := 16#00;&#xD;
																		END_IF;&#xD;
																		&#xD;
																		BytesInMessage := 6;	//Number bytes after the MBAP Header&#xD;
																		ToAryByte(BytesInMessage, _HIGH_LOW, SendAr[4]);&#xD;
																		PacketSize := 12;&#xD;
																		State := 110;&#xD;
																	ELSE&#xD;
																		//Address error&#xD;
																		ErrorRequestNO := RequestPnt;&#xD;
																		ErrorID := 16#1001; //Modbus address outside of Array boundary&#xD;
																		State := 2000;&#xD;
																	END_IF;&#xD;
		&#xD;
		eFun#Fn06_WriteSingleRegister:			IF UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal) &gt;= LOWER_BOUND(HoldingRegisters, 1) AND UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal)  &lt;= UPPER_BOUND(HoldingRegisters, 1) THEN&#xD;
																		State := DINT_TO_UINT(100 + EnumToNum(Requests[RequestPnt].FunctionCode));&#xD;
																		&#xD;
																		ToAryByte(TransactionID, _HIGH_LOW, SendAr[0]);&#xD;
																		SendAr[2] := 16#00;&#xD;
																		SendAr[3] := 16#00;&#xD;
																		SendAr[6] := UINT_TO_BYTE(Requests[RequestPnt].NodeAdr);&#xD;
																		SendAr[7] := DINT_TO_BYTE(Requests[RequestPnt].FunctionCode);&#xD;
																		ToAryByte(Requests[RequestPnt].Write.StartAddressRemote, _HIGH_LOW, SendAr[8]);&#xD;
																		ToAryByte(HoldingRegisters[Requests[RequestPnt].Write.StartAddressLocal], _HIGH_LOW, SendAr[10]);&#xD;
																		&#xD;
																		BytesInMessage := 6;	//Number bytes after the MBAP Header&#xD;
																		ToAryByte(BytesInMessage, _HIGH_LOW, SendAr[4]);&#xD;
																		PacketSize := 12;&#xD;
																		State := 110;&#xD;
																	ELSE&#xD;
																		//Address error&#xD;
																		ErrorRequestNO := RequestPnt;&#xD;
																		ErrorID := 16#1001; //Modbus address outside of Array boundary&#xD;
																		State := 2000;&#xD;
																	END_IF;&#xD;
		&#xD;
		eFun#Fn15_WriteMultipleCoils:			IF UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal) &gt;= LOWER_BOUND(Coils, 1) AND UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal + Requests[RequestPnt].Write.Count - 1)  &lt;= UPPER_BOUND(Coils, 1) THEN&#xD;
																		State := DINT_TO_UINT(100 + EnumToNum(Requests[RequestPnt].FunctionCode));&#xD;
																		&#xD;
																		ToAryByte(TransactionID, _HIGH_LOW, SendAr[0]);&#xD;
																		SendAr[2] := 16#00;&#xD;
																		SendAr[3] := 16#00;&#xD;
																		SendAr[6] := UINT_TO_BYTE(Requests[RequestPnt].NodeAdr);&#xD;
																		SendAr[7] := DINT_TO_BYTE(Requests[RequestPnt].FunctionCode);&#xD;
																		ToAryByte(Requests[RequestPnt].Write.StartAddressRemote, _HIGH_LOW, SendAr[8]);&#xD;
																		ToAryByte(Requests[RequestPnt].Write.Count, _HIGH_LOW, SendAr[10]);&#xD;
																		BytePnt := 13;&#xD;
																		BitPnt := 0;&#xD;
																		FOR i := Requests[RequestPnt].Write.StartAddressLocal TO (Requests[RequestPnt].Write.StartAddressLocal + Requests[RequestPnt].Write.Count -1) DO&#xD;
																			OutABit(InOut := SendAr[BytePnt], Pos := BitPnt, BitVal := Coils[i]);&#xD;
																			Inc(BitPnt);&#xD;
																			IF i &lt; UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal + Requests[RequestPnt].Write.Count -1) THEN&#xD;
																				//To avoid incrementing BytePnt if the last coil is written to the end of a byte&#xD;
																				IF BitPnt &gt;= 8 THEN&#xD;
																					Inc(BytePnt);&#xD;
																					BitPnt := 0;&#xD;
																				END_IF;&#xD;
																			END_IF;&#xD;
																		END_FOR;&#xD;
																		SendAr[12] := UINT_TO_BYTE(BytePnt - UINT#13 + UINT#1);	//Number of bytes containing coil data&#xD;
																		&#xD;
																		BytesInMessage := UINT#7 + BYTE_TO_UINT(SendAr[12]);	//Number bytes after the MBAP Header&#xD;
																		ToAryByte(BytesInMessage, _HIGH_LOW, SendAr[4]);&#xD;
																		PacketSize := BytePnt + 1;&#xD;
																		State := 110;&#xD;
																	ELSE&#xD;
																		//Address error&#xD;
																		ErrorRequestNO := RequestPnt;&#xD;
																		ErrorID := 16#1001; //Modbus address outside of Array boundary&#xD;
																		State := 2000;&#xD;
																	END_IF;&#xD;
		&#xD;
		eFun#Fn16_WriteMultipleRegisters:	IF UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal) &gt;= LOWER_BOUND(HoldingRegisters, 1) AND UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal + Requests[RequestPnt].Write.Count - 1)  &lt;= UPPER_BOUND(HoldingRegisters, 1) THEN&#xD;
																		State := DINT_TO_UINT(100 + EnumToNum(Requests[RequestPnt].FunctionCode));&#xD;
																		&#xD;
																		ToAryByte(TransactionID, _HIGH_LOW, SendAr[0]);&#xD;
																		SendAr[2] := 16#00;&#xD;
																		SendAr[3] := 16#00;&#xD;
																		SendAr[6] := UINT_TO_BYTE(Requests[RequestPnt].NodeAdr);&#xD;
																		SendAr[7] := DINT_TO_BYTE(Requests[RequestPnt].FunctionCode);&#xD;
																		ToAryByte(Requests[RequestPnt].Write.StartAddressRemote, _HIGH_LOW, SendAr[8]);&#xD;
																		ToAryByte(Requests[RequestPnt].Write.Count, _HIGH_LOW, SendAr[10]);&#xD;
																		BytePnt := 13;&#xD;
																		FOR i := Requests[RequestPnt].Write.StartAddressLocal TO (Requests[RequestPnt].Write.StartAddressLocal + Requests[RequestPnt].Write.Count -1) DO&#xD;
																			ToAryByte(HoldingRegisters[i], _HIGH_LOW, SendAr[BytePnt]);&#xD;
																			BytePnt := BytePnt + UINT#2;&#xD;
																		END_FOR;&#xD;
																		SendAr[12] := UINT_TO_BYTE(Requests[RequestPnt].Write.Count * UINT#2); //Number of bytes containing written data&#xD;
																		&#xD;
																		BytesInMessage := UINT#7 + BYTE_TO_UINT(SendAr[12]);	//Number bytes after the MBAP Header&#xD;
																		ToAryByte(BytesInMessage, _HIGH_LOW, SendAr[4]);&#xD;
																		PacketSize := BytePnt;&#xD;
																		State := 110;&#xD;
																	ELSE&#xD;
																		//Address error&#xD;
																		ErrorRequestNO := RequestPnt;&#xD;
																		ErrorID := 16#1001; //Modbus address outside of Array boundary&#xD;
																		State := 2000;&#xD;
																	END_IF;&#xD;
&#xD;
&#xD;
		eFun#Fn23_WriteReadMultipleRegisters:	IF UINT_TO_DINT(Requests[RequestPnt].Read.StartAddressLocal) &gt;= LOWER_BOUND(HoldingRegisters, 1) AND UINT_TO_DINT(Requests[RequestPnt].Read.StartAddressLocal + Requests[RequestPnt].Read.Count - 1)  &lt;= UPPER_BOUND(HoldingRegisters, 1) AND&#xD;
																				UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal) &gt;= LOWER_BOUND(HoldingRegisters, 1) AND UINT_TO_DINT(Requests[RequestPnt].Write.StartAddressLocal + Requests[RequestPnt].Write.Count - 1)  &lt;= UPPER_BOUND(HoldingRegisters, 1) THEN&#xD;
																				State := DINT_TO_UINT(100 + EnumToNum(Requests[RequestPnt].FunctionCode));&#xD;
																			&#xD;
																				ToAryByte(TransactionID, _HIGH_LOW, SendAr[0]);&#xD;
																				SendAr[2] := 16#00;&#xD;
																				SendAr[3] := 16#00;&#xD;
																				SendAr[6] := UINT_TO_BYTE(Requests[RequestPnt].NodeAdr);&#xD;
																				SendAr[7] := DINT_TO_BYTE(Requests[RequestPnt].FunctionCode);&#xD;
																				ToAryByte(Requests[RequestPnt].Read.StartAddressRemote, _HIGH_LOW, SendAr[8]);&#xD;
																				ToAryByte(Requests[RequestPnt].Read.Count, _HIGH_LOW, SendAr[10]);&#xD;
																				ToAryByte(Requests[RequestPnt].Write.StartAddressRemote, _HIGH_LOW, SendAr[12]);&#xD;
																				ToAryByte(Requests[RequestPnt].Write.Count, _HIGH_LOW, SendAr[14]);&#xD;
																				BytePnt := 17;&#xD;
																				FOR i := Requests[RequestPnt].Write.StartAddressLocal TO (Requests[RequestPnt].Write.StartAddressLocal + Requests[RequestPnt].Write.Count -1) DO&#xD;
																					ToAryByte(HoldingRegisters[i], _HIGH_LOW, SendAr[BytePnt]);&#xD;
																					BytePnt := BytePnt + UINT#2;&#xD;
																				END_FOR;&#xD;
																				SendAr[16] := UINT_TO_BYTE(Requests[RequestPnt].Write.Count * UINT#2); //Number of bytes containing written data&#xD;
																				&#xD;
																				&#xD;
																				BytesInMessage := UINT#11 + BYTE_TO_UINT(SendAr[16]);	//Number bytes after the MBAP Header&#xD;
																				ToAryByte(BytesInMessage, _HIGH_LOW, SendAr[4]);&#xD;
																				PacketSize := BytePnt;&#xD;
																				State := 110;&#xD;
																			ELSE&#xD;
																				//Address error&#xD;
																				ErrorRequestNO := RequestPnt;&#xD;
																				ErrorID := 16#1001; //Modbus address outside of Array boundary&#xD;
																				State := 2000;&#xD;
																			END_IF;&#xD;
&#xD;
	ELSE&#xD;
		//Invalid function code&#xD;
		ErrorRequestNO := RequestPnt;&#xD;
		ErrorID := 16#1002; //Invalid modbus function code&#xD;
		State := 2000;&#xD;
	END_CASE;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
IF State = 110 THEN&#xD;
	IF PacketSize &lt; SizeOfAry(SendAr) THEN&#xD;
		iSktTCPSend(Execute := FALSE, Socket := Socket, SendDat := SendAr[0], Size := PacketSize);&#xD;
		State := 120;&#xD;
	ELSE&#xD;
		ErrorRequestNO := RequestPnt;&#xD;
		ErrorID := 16#2012; //Too many bytes in packet&#xD;
		State := 2000;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 120 THEN&#xD;
	iSktTCPSend(Execute := TRUE, Socket := Socket, SendDat := SendAr[0], Size := PacketSize);&#xD;
	&#xD;
	IF NOT iSktTCPSend.Busy THEN&#xD;
		IF iSktTCPSend.Done THEN&#xD;
			State := 130;&#xD;
		END_IF;&#xD;
		&#xD;
		IF iSktTCPSend.Error THEN&#xD;
			ErrorRequestNO := RequestPnt;&#xD;
			ErrorID := iSktTCPSend.ErrorID;&#xD;
			CloseSocket := TRUE;&#xD;
			State := 2000;&#xD;
		END_IF;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 130 THEN&#xD;
	iSktTCPRcv(Execute := FALSE, Socket := Socket, TimeOut := TimeOut, Size := 2000, RcvDat := RcvAr[0]);&#xD;
	State := 140;&#xD;
END_IF;&#xD;
&#xD;
IF State = 140 THEN&#xD;
	iSktTCPRcv(Execute := TRUE, Socket := Socket, TimeOut := TimeOut, Size := 2000, RcvDat := RcvAr[0]);&#xD;
	IF NOT iSktTCPRcv.Busy THEN&#xD;
		IF iSktTCPRcv.Done THEN&#xD;
			State := 150;&#xD;
		END_IF;&#xD;
		&#xD;
		IF iSktTCPRcv.Error THEN&#xD;
			ErrorRequestNO := RequestPnt;&#xD;
			ErrorID := iSktTCPRcv.ErrorID;&#xD;
			State := 2000;&#xD;
		END_IF;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 150 THEN&#xD;
	//Received response from the server&#xD;
	IF SendAr[0] = RcvAr[0] AND SendAr[1] = RcvAr[1] THEN&#xD;
		//Transaction ID match&#xD;
		IF SendAr[6] = RcvAr[6] THEN&#xD;
			//Modbus address match&#xD;
			IF SendAr[7] = RcvAr[7] THEN&#xD;
				//Function Code match&#xD;
				CASE Requests[RequestPnt].FunctionCode OF&#xD;
					eFun#Fn01_ReadCoils:								ModbusByteCount := BYTE_TO_UINT(RcvAr[8]);&#xD;
																					BitPnt := 0;&#xD;
																					BytePnt := 9;&#xD;
																					FOR i := Requests[RequestPnt].Read.StartAddressLocal TO (Requests[RequestPnt].Read.StartAddressLocal + Requests[RequestPnt].Read.Count - 1) DO&#xD;
																						Coils[i] := TestABit(In := RcvAr[BytePnt], Pos := BitPnt);&#xD;
																						Inc(BitPnt);&#xD;
																						IF BitPnt &gt;= 8 THEN&#xD;
																							Inc(BytePnt);&#xD;
																							BitPnt := 0;&#xD;
																							Dec(ModbusByteCount);&#xD;
																							IF ModbusByteCount = 0 THEN&#xD;
																								EXIT;&#xD;
																							END_IF;&#xD;
																						END_IF;&#xD;
																					END_FOR;&#xD;
																					State := 1000;&#xD;
																					&#xD;
					eFun#Fn02_ReadDiscreteInputs:				ModbusByteCount := BYTE_TO_UINT(RcvAr[8]);&#xD;
																					BitPnt := 0;&#xD;
																					BytePnt := 9;&#xD;
																					FOR i := Requests[RequestPnt].Read.StartAddressLocal TO (Requests[RequestPnt].Read.StartAddressLocal + Requests[RequestPnt].Read.Count - 1) DO&#xD;
																						DiscreteInputs[i] := TestABit(In := RcvAr[BytePnt], Pos := BitPnt);&#xD;
																						Inc(BitPnt);&#xD;
																						IF BitPnt &gt;= 8 THEN&#xD;
																							Inc(BytePnt);&#xD;
																							BitPnt := 0;&#xD;
																							Dec(ModbusByteCount);&#xD;
																							IF ModbusByteCount = 0 THEN&#xD;
																								EXIT;&#xD;
																							END_IF;&#xD;
																						END_IF;&#xD;
																					END_FOR;&#xD;
																					State := 1000;&#xD;
																					&#xD;
					eFun#Fn03_ReadHoldingRegisters:			ModbusByteCount := BYTE_TO_UINT(RcvAr[8]);&#xD;
																					IF ModbusByteCount = (Requests[RequestPnt].Read.Count * UINT#2) THEN&#xD;
																						BytePnt := UINT#9;&#xD;
																						FOR i := Requests[RequestPnt].Read.StartAddressLocal TO (Requests[RequestPnt].Read.StartAddressLocal + Requests[RequestPnt].Read.Count - 1) DO&#xD;
																							AryByteTo(In := RcvAr[BytePnt], Size := UINT#2, Order := _HIGH_LOW, OutVal := HoldingRegisters[i]);&#xD;
																							BytePnt := BytePnt + UINT#2;&#xD;
																						END_FOR;&#xD;
																						State := 1000;&#xD;
																					ELSE&#xD;
																						ErrorRequestNO := RequestPnt;&#xD;
																						ErrorID := 16#1010; //Mismatch of bytes in response&#xD;
																						State := 2000;&#xD;
																					END_IF;&#xD;
																					&#xD;
																					&#xD;
					eFun#Fn04_ReadInputRegisters:				ModbusByteCount := BYTE_TO_UINT(RcvAr[8]);&#xD;
																					IF ModbusByteCount = (Requests[RequestPnt].Read.Count * UINT#2) THEN&#xD;
																						BytePnt := UINT#9;&#xD;
																						FOR i := Requests[RequestPnt].Read.StartAddressLocal TO (Requests[RequestPnt].Read.StartAddressLocal + Requests[RequestPnt].Read.Count - 1) DO&#xD;
																							AryByteTo(In := RcvAr[BytePnt], Size := UINT#2, Order := _HIGH_LOW, OutVal := InputRegisters[i]);&#xD;
																							BytePnt := BytePnt + UINT#2;&#xD;
																						END_FOR;&#xD;
																						State := 1000;&#xD;
																					ELSE&#xD;
																						ErrorRequestNO := RequestPnt;&#xD;
																						ErrorID := 16#1010; //Mismatch of bytes in response&#xD;
																						State := 2000;&#xD;
																					END_IF;&#xD;
																					&#xD;
					eFun#Fn05_WriteSingleCoil:					&#xD;
																					IF RcvAr[8] = SendAr[8] AND RcvAr[9] = SendAr[9] THEN&#xD;
																						//Address match&#xD;
																						State := 1000;&#xD;
																					ELSE&#xD;
																						ErrorRequestNO := RequestPnt;&#xD;
																						ErrorID := 16#1011; //Mismatch written address in response&#xD;
																						State := 2000;&#xD;
																					END_IF;&#xD;
					&#xD;
					eFun#Fn06_WriteSingleRegister:					&#xD;
																					IF RcvAr[8] = SendAr[8] AND RcvAr[9] = SendAr[9] THEN&#xD;
																						//Address match&#xD;
																						State := 1000;&#xD;
																					ELSE&#xD;
																						ErrorRequestNO := RequestPnt;&#xD;
																						ErrorID := 16#1011; //Mismatch written address in response&#xD;
																						State := 2000;&#xD;
																					END_IF;&#xD;
																					&#xD;
					eFun#Fn15_WriteMultipleCoils:					&#xD;
																					IF RcvAr[8] = SendAr[8] AND RcvAr[9] = SendAr[9] THEN&#xD;
																						//Address match&#xD;
																						State := 1000;&#xD;
																					ELSE&#xD;
																						ErrorRequestNO := RequestPnt;&#xD;
																						ErrorID := 16#1011; //Mismatch written address in response&#xD;
																						State := 2000;&#xD;
																					END_IF;&#xD;
					&#xD;
					eFun#Fn16_WriteMultipleRegisters:					&#xD;
																					IF RcvAr[8] = SendAr[8] AND RcvAr[9] = SendAr[9] THEN&#xD;
																						//Address match&#xD;
																						State := 1000;&#xD;
																					ELSE&#xD;
																						ErrorRequestNO := RequestPnt;&#xD;
																						ErrorID := 16#1011; //Mismatch written address in response&#xD;
																						State := 2000;&#xD;
																					END_IF;&#xD;
					&#xD;
					&#xD;
					eFun#Fn23_WriteReadMultipleRegisters:		ModbusByteCount := BYTE_TO_UINT(RcvAr[8]);&#xD;
																							IF ModbusByteCount = (Requests[RequestPnt].Read.Count * UINT#2) THEN&#xD;
																								BytePnt := UINT#9;&#xD;
																								FOR i := Requests[RequestPnt].Read.StartAddressLocal TO (Requests[RequestPnt].Read.StartAddressLocal + Requests[RequestPnt].Read.Count - 1) DO&#xD;
																									AryByteTo(In := RcvAr[BytePnt], Size := UINT#2, Order := _HIGH_LOW, OutVal := HoldingRegisters[i]);&#xD;
																									BytePnt := BytePnt + UINT#2;&#xD;
																								END_FOR;&#xD;
																								State := 1000;&#xD;
																							ELSE&#xD;
																								ErrorRequestNO := RequestPnt;&#xD;
																								ErrorID := 16#1010; //Mismatch of bytes in response&#xD;
																								State := 2000;&#xD;
																							END_IF;&#xD;
					&#xD;
					&#xD;
				ELSE&#xD;
					ErrorRequestNO := RequestPnt;&#xD;
					ErrorID := 16#1013; //Unknown function code&#xD;
					State := 2000;&#xD;
				END_CASE;&#xD;
			ELSE&#xD;
				IF BYTE_TO_UINT(RcvAr[7]) = BYTE_TO_UINT(SendAr[7]) + UINT#16#80 THEN&#xD;
					ErrorID := 16#0C10; //Exceptional Modbus Response&#xD;
					ErrorIDEx := BYTE_TO_DWORD(RcvAr[8]); // Exception code from modbus&#xD;
				ELSE&#xD;
					ErrorID := 16#1009; // Function code mismatch&#xD;
				END_IF;&#xD;
				ErrorRequestNO := RequestPnt;&#xD;
				State := 2000;&#xD;
			END_IF;&#xD;
		ELSE&#xD;
			ErrorRequestNO := RequestPnt;&#xD;
			ErrorID := 16#1008;	//Modbus address mismatch&#xD;
			State := 2000;&#xD;
		END_IF;&#xD;
	ELSE&#xD;
		ErrorRequestNO := RequestPnt;&#xD;
		ErrorID := 16#1007; //TransactionID mismatch&#xD;
		State := 2000;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
&#xD;
IF State = 1000 THEN&#xD;
	//Request finished&#xD;
	Inc(RequestPnt);&#xD;
	IF RequestPnt &gt; UPPER_BOUND(Requests, 1) THEN&#xD;
		State := 3000;&#xD;
	ELSE&#xD;
		State := 60;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 2000 THEN&#xD;
	//Error&#xD;
	//Making a one shot&#xD;
	Inc(Test);&#xD;
	IF Error THEN&#xD;
		Error := FALSE;&#xD;
		State := 2010;&#xD;
	ELSE&#xD;
		Error := TRUE;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 2010 THEN&#xD;
	IF CloseSocket THEN&#xD;
		RequestCycleTime := T#0s;&#xD;
		IF Socket.Handle &lt;&gt; 0 THEN&#xD;
			iSktClose(Execute := FALSE, Socket := Socket);&#xD;
			State := 2020;&#xD;
		ELSE&#xD;
			State := 0;&#xD;
		END_IF;&#xD;
		CloseSocket := FALSE;&#xD;
	ELSE&#xD;
		State := 1000;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 2020 THEN&#xD;
	iSktClose(Execute := TRUE, Socket := Socket);&#xD;
	&#xD;
	IF NOT iSktClose.Busy THEN&#xD;
		State := 0;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 3000 THEN&#xD;
	//Finished with Request cycle&#xD;
	CycleTime_ns := ULINT_TO_LINT(Get1msCnt() - RequestCycleStart) * 1000000;&#xD;
	RequestCycleTime := NanoSecToTime(CycleTime_ns);&#xD;
	State := 3010;&#xD;
END_IF;&#xD;
&#xD;
IF State = 3010 THEN&#xD;
	//Making a one shot&#xD;
	IF RequestCycleDone THEN&#xD;
		RequestCycleDone := FALSE;&#xD;
		State := 30;&#xD;
	ELSE&#xD;
		RequestCycleDone := TRUE;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
</Text></StructuredTextModel>