<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>IF(Master_Feeder_Options.Sequential_Feeding) THEN&#xD;
	HMI_Feeder_Sequences_Retained.Enabled[0]:=TRUE;&#xD;
ELSE&#xD;
	HMI_Feeder_Sequences_Retained.Enabled[0]:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
// When a recipe is selected then transfer automatically&#xD;
Recipe_Transfered_TP(In := HMI_Transfer_Flag, PT := T#1s);&#xD;
&#xD;
Recipe_Transfered_F(Clk := Recipe_Transfered_TP.Q);&#xD;
IF (Recipe_Transfered_F.Q) THEN&#xD;
	HMI_Transfer_Flag := FALSE;&#xD;
END_IF;&#xD;
&#xD;
Recipe_Transfered_RT(Clk:=(HMI_Feeder_Data.Reset_Sequence OR Recipe_Transfered_F.Q));&#xD;
&#xD;
Act_Sequences.Vel := HMI_Feeder_Sequences_Retained.Vel;&#xD;
Act_Sequences.Accel := HMI_Feeder_Sequences_Retained.Accel;&#xD;
Act_Sequences.Decel := HMI_Feeder_Sequences_Retained.Decel;&#xD;
Act_Sequences.No_Of_Pieces := HMI_Feeder_Sequences_Retained.No_Of_Pieces;&#xD;
Act_Sequences.No_Of_Steps := HMI_Feeder_Sequences_Retained.No_Of_Steps;&#xD;
	&#xD;
// Always transfer the distance if there is only one step&#xD;
IF (HMI_Feeder_Sequences_Retained.Enabled[1] = FALSE) THEN&#xD;
	Act_Sequences.Distance[0] := HMI_Feeder_Sequences_Retained.Distance[0];&#xD;
END_IF;&#xD;
	&#xD;
IF (Recipe_Transfered_RT.Q) OR (NOT Master_Feeder_Options.Sequential_Feeding) THEN&#xD;
	FOR I:=0 TO 30 DO&#xD;
		Act_Sequences.Enabled[I] := HMI_Feeder_Sequences_Retained.Enabled[I];&#xD;
		Act_Sequences.Distance[I] := REAL_TO_LREAL(HMI_Feeder_Sequences_Retained.Distance[I]);&#xD;
		Act_Sequences.Gag[I] := HMI_Feeder_Sequences_Retained.Gag[I];&#xD;
	END_FOR;&#xD;
	&#xD;
	Sequence_Transfered_Latch := TRUE;&#xD;
	Feed_Sequence_Changed := FALSE;&#xD;
ELSIF (Act_Sequences.Enabled[1] = FALSE) THEN&#xD;
		Act_Sequences.Enabled[0] := HMI_Feeder_Sequences_Retained.Enabled[0];&#xD;
		Act_Sequences.Distance[0] := REAL_TO_LREAL(HMI_Feeder_Sequences_Retained.Distance[0]);&#xD;
		Act_Sequences.Gag[0] := HMI_Feeder_Sequences_Retained.Gag[0];&#xD;
END_IF;&#xD;
&#xD;
Feed_Sequence_Changed := NOT (Act_Sequences.Vel = HMI_Feeder_Sequences_Retained.Vel) OR Feed_Sequence_Changed;&#xD;
Feed_Sequence_Changed := NOT (Act_Sequences.Accel = HMI_Feeder_Sequences_Retained.Accel) OR Feed_Sequence_Changed;&#xD;
Feed_Sequence_Changed := NOT (Act_Sequences.Decel = HMI_Feeder_Sequences_Retained.Decel) OR Feed_Sequence_Changed;&#xD;
Feed_Sequence_Changed := NOT (Act_Sequences.No_Of_Pieces = HMI_Feeder_Sequences_Retained.No_Of_Pieces) OR Feed_Sequence_Changed;&#xD;
&#xD;
FOR I:=0 TO 30 DO&#xD;
	// Provide a way to showcase if any changes were made to the sequences&#xD;
	&#xD;
	// Disregard changes made to the first distance -- assuming we have no other sequences after&#xD;
	IF (HMI_Feeder_Sequences_Retained.Enabled[1] = TRUE) THEN&#xD;
		Feed_Sequence_Changed := NOT (Act_Sequences.Distance[I] = HMI_Feeder_Sequences_Retained.Distance[I]) OR Feed_Sequence_Changed;&#xD;
	END_IF;&#xD;
	&#xD;
	Feed_Sequence_Changed := NOT (Act_Sequences.Enabled[I] = HMI_Feeder_Sequences_Retained.Enabled[I]) OR Feed_Sequence_Changed;&#xD;
	Feed_Sequence_Changed := NOT (Act_Sequences.Gag[I] = HMI_Feeder_Sequences_Retained.Gag[I]) OR Feed_Sequence_Changed;&#xD;
	&#xD;
	// Prevent enabling of sequences past the one right after the last enabled one.&#xD;
	IF (I &gt; 1) AND (NOT HMI_Feeder_Sequences_Retained.Enabled[I-1]) THEN&#xD;
		HMI_Feeder_Sequences_Retained.Enabled[I] := FALSE;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
	&#xD;
HMI_Feeder_Sequences_Retained.No_Of_Steps := Act_Sequences.No_Of_Steps;&#xD;
&#xD;
FOR Condition_Iterator:=0 TO 31 BY 1 DO&#xD;
	IF HMI_Display_Details[Condition_Iterator] THEN&#xD;
		Global_Conditions[32]:=Global_Conditions[Condition_Iterator];&#xD;
		HMI_Clicked_User_Condition:=Condition_Iterator+1;&#xD;
		Selected_Condition := Condition_Iterator;&#xD;
	END_IF;&#xD;
	  IF HMI_Clicked_User_Condition&gt;16 THEN&#xD;
		HMI_Clicked_User_Condition :=HMI_Clicked_User_Condition-16;&#xD;
	ELSE&#xD;
		HMI_Clicked_User_Condition:=HMI_Clicked_User_Condition;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
IF HMI_User_Condition_Save THEN&#xD;
	Global_Conditions[Selected_Condition]:=Global_Conditions[32];&#xD;
END_IF;&#xD;
&#xD;
// Show the proper gauge for the user condition CAM&#xD;
IF (Global_Conditions[32].Lower_Pos &lt;= Global_Conditions[32].Higher_Pos) THEN&#xD;
	HMI_Condition_Cam := TRUE;&#xD;
ELSE&#xD;
	HMI_Condition_Cam := FALSE;&#xD;
END_IF;&#xD;
&#xD;
IF (Global_Conditions[32].Action_Type &lt;&gt; Global_Conditions[Selected_Condition].Action_Type) OR//&#xD;
	(Global_Conditions[32].Direction &lt;&gt; Global_Conditions[Selected_Condition].Direction) OR//&#xD;
	(Global_Conditions[32].Enabled &lt;&gt; Global_Conditions[Selected_Condition].Enabled) OR//&#xD;
	(Global_Conditions[32].Higher_Pos &lt;&gt; Global_Conditions[Selected_Condition].Higher_Pos) OR//&#xD;
	(Global_Conditions[32].Input_Number &lt;&gt; Global_Conditions[Selected_Condition].Input_Number) OR//&#xD;
	(Global_Conditions[32].Kind &lt;&gt; Global_Conditions[Selected_Condition].Kind) OR//&#xD;
	(Global_Conditions[32].Lower_Pos &lt;&gt; Global_Conditions[Selected_Condition].Lower_Pos) OR//	&#xD;
	(Global_Conditions[32].Name &lt;&gt; Global_Conditions[Selected_Condition].Name) OR //&#xD;
	(Global_Conditions[32].Pulse &lt;&gt; Global_Conditions[Selected_Condition].Pulse) OR//&#xD;
	(Global_Conditions[32].T_OF &lt;&gt; Global_Conditions[Selected_Condition].T_OF) OR//&#xD;
	(Global_Conditions[32].Timer_Type &lt;&gt; Global_Conditions[Selected_Condition].Timer_Type) THEN//&#xD;
	HMI_Condition_Changed := TRUE;&#xD;
ELSE&#xD;
	HMI_Condition_Changed := FALSE;&#xD;
END_IF;&#xD;
&#xD;
Global_Conditions[32].In_Range := Global_Conditions[Selected_Condition].In_Range;&#xD;
Global_Conditions[32].Input_Ok := Global_Conditions[Selected_Condition].Input_Ok;&#xD;
&#xD;
</Text></StructuredTextModel>