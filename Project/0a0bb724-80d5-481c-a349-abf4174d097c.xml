<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>(* Provide adjustment factor to the move *)&#xD;
Adj_Distance := Adj_Feed(Distance, Adj_Factor);&#xD;
&#xD;
(* Convert or not speed, accel and distance - The internals require that the distance be in mm *)&#xD;
IF (NOT Unit) THEN&#xD;
	Conv_Adj_Distance := Imperial_To_Metric(Adj_Distance);&#xD;
	Speed_O := Imperial_To_Metric(Speed);&#xD;
	Accel_O := Imperial_To_Metric(Accel);&#xD;
	Decel_O := Imperial_To_Metric(Decel);&#xD;
	&#xD;
	Unit_Str := 'in';&#xD;
ELSE&#xD;
	Conv_Adj_Distance := Adj_Distance;&#xD;
	Speed_O := Speed;&#xD;
	Accel_O := Accel;&#xD;
	Decel_O := Decel;&#xD;
	&#xD;
	Unit_Str := 'mm';&#xD;
END_IF;&#xD;
&#xD;
(* Compensate for backlash in the feeder *)&#xD;
	(* When going for a negative feed then remove the backlash distance so the feeder goes further back *)&#xD;
IF (Last_Feed_Positive = TRUE) AND (Conv_Adj_Distance &lt; 0) THEN&#xD;
	Distance_O := Conv_Adj_Distance - Backlash_Compensation;&#xD;
	(* When going for a positive feed then add the backlash distance so the feeder goes further forward *)&#xD;
ELSIF (Last_Feed_Positive = FALSE) AND (Conv_Adj_Distance &gt; 0) THEN&#xD;
	Distance_O := Conv_Adj_Distance + Backlash_Compensation;&#xD;
	(* If we are going in the same direction as the last feed then consider we have no need to compensate for backlash *)&#xD;
ELSE&#xD;
	Distance_O := Conv_Adj_Distance;&#xD;
END_IF;</Text></StructuredTextModel>