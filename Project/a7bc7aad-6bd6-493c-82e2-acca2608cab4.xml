{"CLs":[{"__type":"IST","EID":"3de968b4-f4d5-43b9-a0ca-04036abc538a","H":130,"TXT":"\/\/ Make sure we display the raw value on the screen\u000d\u000aHMI_Data_Uncoiler.AI_Raw_Value := HMI_Data_Uncoiler.IOL_Current_Distance;\u000d\u000a\u000d\u000aIF (Master_Uncoiler_Options.IOL_Sensors) THEN\u000d\u000a\u0009HMI_Data_Uncoiler.IOL_Current_Distance := (TO_REAL(Uncoiler_ABB_AI1_Value)+HMI_Data_Uncoiler_Retained.AI_Offset)*HMI_Data_Uncoiler_Retained.AI_Multiplier;\u000d\u000a\u0009\u0009\u000d\u000a\u0009\/\/ Impose limits\u000d\u000a\u0009IF (HMI_Data_Uncoiler.AI_Raw_Value > HMI_Data_Uncoiler_Retained.AI_Scale_Raw_High) THEN\u000d\u000a\u0009\u0009Value := HMI_Data_Uncoiler_Retained.AI_Scale_Raw_High;\u000d\u000a\u0009ELSE\u000d\u000a\u0009\u0009Value := HMI_Data_Uncoiler.AI_Raw_Value;\u000d\u000a\u0009END_IF;\u000d\u000a\u000d\u000a\u0009IF (HMI_Data_Uncoiler.AI_Raw_Value < HMI_Data_Uncoiler_Retained.AI_Scale_Raw_Low) THEN\u000d\u000a\u0009\u0009Value := HMI_Data_Uncoiler_Retained.AI_Scale_Raw_Low;\u000d\u000a\u0009ELSE\u000d\u000a\u0009\u0009Value := HMI_Data_Uncoiler.AI_Raw_Value;\u000d\u000a\u0009END_IF;\u000d\u000a\u0009\u0009\u000d\u000a\u0009\/\/ Transform raw data into scaled Hz value\u000d\u000a\u0009Speed_Value  := ScaleTrans(SclIN:=Value,\u000d\u000a\u0009\u0009\u0009   \u0009\u0009  X0:=HMI_Data_Uncoiler_Retained.AI_Scale_Raw_Low,\u000d\u000a\u0009\u0009\u0009\u0009\u0009  X1:=HMI_Data_Uncoiler_Retained.AI_Scale_Raw_High,\u000d\u000a\u0009\u0009\u0009\u0009\u0009  Y0:=HMI_Data_Uncoiler_Retained.AI_Scale_Speed_Low,\u000d\u000a\u0009\u0009\u0009\u0009\u0009  Y1:=HMI_Data_Uncoiler_Retained.AI_Scale_Speed_High);\u000d\u000a\u000d\u000a\u0009\/\/ If one of the ranges is inverted then consider we need to start the uncoiler from the other direction\u000d\u000a\u0009IF ((HMI_Data_Uncoiler_Retained.AI_Scale_Speed_Low > HMI_Data_Uncoiler_Retained.AI_Scale_Speed_High) AND\u000d\u000a\u0009\u0009(HMI_Data_Uncoiler_Retained.AI_Scale_Raw_Low < HMI_Data_Uncoiler_Retained.AI_Scale_Raw_High)) OR\u000d\u000a\u0009\u0009((HMI_Data_Uncoiler_Retained.AI_Scale_Speed_Low < HMI_Data_Uncoiler_Retained.AI_Scale_Speed_High) AND\u000d\u000a\u0009\u0009(HMI_Data_Uncoiler_Retained.AI_Scale_Raw_Low > HMI_Data_Uncoiler_Retained.AI_Scale_Raw_High)) THEN\u000d\u000a\u0009\u0009Highest_Val := HMI_Data_Uncoiler_Retained.AI_Scale_Speed_Low;\u000d\u000a\u0009\u0009Lowest_Val := HMI_Data_Uncoiler_Retained.AI_Scale_Speed_High;\u000d\u000a\u0009\u0009Switch_Val := TRUE;\u000d\u000a\u0009ELSE\u000d\u000a\u0009\u0009Highest_Val := HMI_Data_Uncoiler_Retained.AI_Scale_Speed_High;\u000d\u000a\u0009\u0009Lowest_Val := HMI_Data_Uncoiler_Retained.AI_Scale_Speed_Low;\u000d\u000a\u0009\u0009Switch_Val := FALSE;\u000d\u000a\u0009END_IF;\u000d\u000a\u000d\u000a\u0009\/\/ Limit the maximum speed at the total range of the scaling\u000d\u000a\u0009IF (Speed_Value > Highest_Val) THEN\u000d\u000a\u0009\u0009Speed_Value := HMI_Data_Uncoiler_Retained.AI_Scale_Speed_High;\u000d\u000a\u0009ELSIF (Speed_Value < Lowest_Val) THEN\u000d\u000a\u0009\u0009Speed_Value := HMI_Data_Uncoiler_Retained.AI_Scale_Raw_Low;\u000d\u000a\u0009END_IF;\u000d\u000a\u000d\u000a\u0009\/\/ Store all values in an array\u000d\u000a\u0009IF (Iterator_SPD < (SizeOfAry(Val_Array))-1) THEN\u000d\u000a\u0009\u0009Val_Array[Iterator_SPD] := Speed_Value;\u000d\u000a\u0009\u0009Iterator_SPD := Iterator_SPD+1;\u000d\u000a\u0009END_IF;\u000d\u000a\u000d\u000a\u0009Filter_Trigger := Get100msClk();\u000d\u000a\u0009Filter_Trigger_R(Clk := Filter_Trigger);\u000d\u000a\u000d\u000a\u0009\/\/ Implement a filter to prevent jerking\u000d\u000a\u0009IF (Filter_Trigger_R.Q) AND (Iterator_SPD > 0) THEN\u000d\u000a\u0009\u0009FOR J:=0 TO Iterator_SPD DO\u000d\u000a\u0009\u0009\u0009Val_Average := Val_Average+TO_REAL(Val_Array[J]);\u000d\u000a\u0009\u0009END_FOR;\u000d\u000a\u0009\u0009\u000d\u000a\u0009\u0009Val_Average := SafeDiv_Real(Val_Average, Iterator_SPD);\u000d\u000a\u0009\u0009Iterator_SPD := 0;\u000d\u000a\u0009\u0009\u000d\u000a\u0009\u0009HMI_Data_Uncoiler.Uncoiler_Scaled_Speed := Val_Average;\u000d\u000a\u0009END_IF;\u000d\u000a\u0009\u0009\u000d\u000a\u0009IF (NOT Switch_Val) THEN\u000d\u000a\u0009\u0009\/\/ If we are above the set distance then start uncoiling\u000d\u000a\u0009\u0009IOL_Uncoiler_Signal := (HMI_Data_Uncoiler.IOL_Current_Distance > HMI_Data_Uncoiler_Retained.IOL_Distance);\u000d\u000a\u0009ELSE\u000d\u000a\u0009\u0009\/\/ If we are below the set distance then start uncoiling\u000d\u000a\u0009\u0009IOL_Uncoiler_Signal := (HMI_Data_Uncoiler.IOL_Current_Distance < HMI_Data_Uncoiler_Retained.IOL_Distance);\u000d\u000a\u0009END_IF;\u000d\u000aEND_IF;","W":400}],"LRI":1,"RRI":2,"VLs":[]}
