<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>Status := State &gt; 10;&#xD;
&#xD;
IF State = 0 THEN&#xD;
	IF Enable THEN&#xD;
		State := 10;&#xD;
	END_IF;&#xD;
	ErrorID := 0;&#xD;
END_IF;&#xD;
&#xD;
IF State = 10 THEN&#xD;
	iNX_SerialBufClear(Execute := FALSE, DevicePort := DevicePort, BufKind := _BUF_SENDRCV, TimeOut := 10);&#xD;
	State := 20;&#xD;
END_IF;&#xD;
&#xD;
IF State = 20 THEN&#xD;
	iNX_SerialBufClear(Execute := TRUE, DevicePort := DevicePort, BufKind := _BUF_SENDRCV, TimeOut := 10);&#xD;
	&#xD;
	IF NOT iNX_SerialBufClear.Busy THEN&#xD;
		IF iNX_SerialBufClear.Done THEN&#xD;
			State := 30;&#xD;
		END_IF;&#xD;
		&#xD;
		IF iNX_SerialBufClear.Error THEN&#xD;
			ErrorID := iNX_SerialBufClear.ErrorID;&#xD;
			State := 300;&#xD;
		END_IF;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 30 THEN&#xD;
	RcvCfg.StartTrig := _eSERIAL_START#_SERIAL_START_NONE;&#xD;
	RcvCfg.EndTrig := _eSERIAL_END#_SERIAL_END_NONE;&#xD;
	RcvBytePnt := 0;&#xD;
	ErrorID := 0;&#xD;
	Clear(RcvDat);&#xD;
	State := 40;&#xD;
END_IF;&#xD;
&#xD;
IF State = 40 THEN&#xD;
	IF Enable THEN&#xD;
		iNX_SerialRcv(Execute := FALSE, DevicePort := DevicePort, RcvDat := RcvDat[RcvBytePnt], Size := 200, RcvCfg := RcvCfg);&#xD;
		State := 50;&#xD;
	ELSE&#xD;
		State := 0;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
IF State = 50 THEN&#xD;
	iNX_SerialRcv(Execute := TRUE, DevicePort := DevicePort, RcvDat := RcvDat[RcvBytePnt], Size := 200, RcvCfg := RcvCfg);&#xD;
	IF NOT iNX_SerialRcv.Busy THEN&#xD;
		IF iNX_SerialRcv.Done THEN&#xD;
			RcvBytePnt := RcvBytePnt + iNX_SerialRcv.RcvSize;&#xD;
			IF StatusFlag_EndDetection AND RcvBytePnt &gt; 0 THEN&#xD;
				//Receive completed&#xD;
				RcvdBytes := RcvBytePnt;&#xD;
				CRC_Word := AryCRC16(In := RcvDat[0], Size := RcvdBytes - UINT#2);&#xD;
				AryByteTo(In := RcvDat[RcvdBytes - 2], Size := UINT#2, Order := _eBYTE_ORDER#_HIGH_LOW, OutVal := Rcvd_CRC_Word);&#xD;
				IF CRC_Word = Rcvd_CRC_Word THEN&#xD;
					State := 100;&#xD;
				ELSE&#xD;
					State := 10;&#xD;
				END_IF;&#xD;
			ELSE&#xD;
				State := 40;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		&#xD;
		IF iNX_SerialRcv.Error THEN&#xD;
			ErrorID := iNX_SerialRcv.ErrorID;&#xD;
			State := 300;&#xD;
		END_IF;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 100 THEN&#xD;
	RcvdSlaveID := BYTE_TO_UINT(RcvDat[0]);&#xD;
	IF RcvdSlaveID = SlaveID THEN&#xD;
		Funct_Code := BYTE_TO_INT(RcvDat[1]);&#xD;
		AryByteTo(RcvDat[2], UINT#2, _HIGH_LOW, Address);&#xD;
		AryByteTo(RcvDat[4], UINT#2, _HIGH_LOW, Qty);&#xD;
		SendDat[0] := RcvDat[0];&#xD;
		SendDat[1] := RcvDat[1];&#xD;
		State := 110;&#xD;
	ELSE&#xD;
		//SlaveID mismatch&#xD;
		State := 10;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 110 THEN&#xD;
	CASE Funct_Code OF&#xD;
&#xD;
			1: // Read Coils&#xD;
			&#xD;
					IF UseAccesslist THEN&#xD;
						AccessGranted := FALSE;&#xD;
						FOR j := LOWER_BOUND(AccessList, 1) TO UPPER_BOUND(AccessList, 1) DO&#xD;
							IF AccessList[j].RegisterType = eRegisterType#Coil THEN&#xD;
								IF AccessList[j].AccessType = eAccess#R OR AccessList[j].AccessType = eAccess#RW THEN&#xD;
									IF  DINT_TO_UDINT(Address) &gt;= AccessList[j].AddressArea.StartAddress AND (DINT_TO_UINT(Address) + Qty) &lt;= (AccessList[j].AddressArea.StartAddress +AccessList[j].AddressArea.Count) THEN&#xD;
										AccessGranted := TRUE;&#xD;
										EXIT;&#xD;
									END_IF;&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
					ELSE&#xD;
						AccessGranted := TRUE;&#xD;
					END_IF;&#xD;
						&#xD;
					&#xD;
					IF Qty = 0 or (Address &lt; LOWER_BOUND(Coils, 1) OR (Address+ Qty) &gt; UPPER_BOUND(Coils, 1)) OR NOT AccessGranted THEN 													// Illegal Data Address&#xD;
						SendDat[1]:=INT_TO_BYTE(INT#16#80 + Funct_Code);&#xD;
						SendDat[2]:=02;&#xD;
						Send_Size:=	3;&#xD;
					ELSE&#xD;
						idxByte := 3;&#xD;
						Clear(SendDat[idxByte]);&#xD;
						idxBit := 0;&#xD;
						FOR j := Address TO Address + Qty -1 DO&#xD;
							OutABit(InOut := SendDat[idxByte], Pos := UINT_TO_USINT(idxBit), BitVal := Coils[j]);&#xD;
							Inc(idxBit);&#xD;
							IF j &lt; Address + Qty -1 THEN&#xD;
								IF idxBit &gt;= UINT#8 THEN&#xD;
									idxBit := 0;&#xD;
									Inc(idxByte);&#xD;
									Clear(SendDat[idxByte]);&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
						SendDat[2]:= 	UINT_TO_BYTE(idxByte - 2);					// Byte number containing the coils			&#xD;
						Send_Size :=			idxByte + 1;										// Size before adding CRC checksum&#xD;
					END_IF;&#xD;
&#xD;
			2: // Read discret inputs&#xD;
					IF UseAccesslist THEN&#xD;
						AccessGranted := FALSE;&#xD;
						FOR j := LOWER_BOUND(AccessList, 1) TO UPPER_BOUND(AccessList, 1) DO&#xD;
							IF AccessList[j].RegisterType = eRegisterType#DiscreteInput THEN&#xD;
								IF AccessList[j].AccessType = eAccess#R OR AccessList[j].AccessType = eAccess#RW THEN&#xD;
									IF  DINT_TO_UDINT(Address) &gt;= AccessList[j].AddressArea.StartAddress AND (DINT_TO_UINT(Address) + Qty) &lt;= (AccessList[j].AddressArea.StartAddress +AccessList[j].AddressArea.Count) THEN&#xD;
										AccessGranted := TRUE;&#xD;
										EXIT;&#xD;
									END_IF;&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
					ELSE&#xD;
						AccessGranted := TRUE;&#xD;
					END_IF;&#xD;
					&#xD;
					IF Qty = 0 or (Address &lt; LOWER_BOUND(DiscreteInputs, 1) OR (Address+ Qty) &gt; UPPER_BOUND(DiscreteInputs, 1)) OR NOT AccessGranted THEN 													// Illegal Data Address&#xD;
						SendDat[1]:=INT_TO_BYTE(INT#16#80 + Funct_Code);&#xD;
						SendDat[2]:=02;&#xD;
						Send_Size:=	3;&#xD;
					ELSE&#xD;
						idxByte := 3;&#xD;
						Clear(SendDat[idxByte]);&#xD;
						idxBit := 0;&#xD;
						FOR j := Address TO Address + Qty -1 DO&#xD;
							OutABit(InOut := SendDat[idxByte], Pos := UINT_TO_USINT(idxBit), BitVal := DiscreteInputs[j]);&#xD;
							Inc(idxBit);&#xD;
							IF j &lt; Address + Qty -1 THEN&#xD;
								IF idxBit &gt;= UINT#8 THEN&#xD;
									idxBit := 0;&#xD;
									Inc(idxByte);&#xD;
									Clear(SendDat[idxByte]);&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
						SendDat[2]:= 	UINT_TO_BYTE(idxByte - 2);					// Byte number containing the coils			&#xD;
						Send_Size :=			idxByte + 1;										// Size before adding CRC checksum&#xD;
					END_IF;&#xD;
&#xD;
		&#xD;
			3:  // Read Holding Registers	Fn03&#xD;
					IF UseAccesslist THEN&#xD;
						AccessGranted := FALSE;&#xD;
						FOR j := LOWER_BOUND(AccessList, 1) TO UPPER_BOUND(AccessList, 1) DO&#xD;
							IF AccessList[j].RegisterType = eRegisterType#HoldingRegister THEN&#xD;
								IF AccessList[j].AccessType = eAccess#R OR AccessList[j].AccessType = eAccess#RW THEN&#xD;
									IF  DINT_TO_UDINT(Address) &gt;= AccessList[j].AddressArea.StartAddress AND (DINT_TO_UINT(Address) + Qty) &lt;= (AccessList[j].AddressArea.StartAddress +AccessList[j].AddressArea.Count) THEN&#xD;
										AccessGranted := TRUE;&#xD;
										EXIT;&#xD;
									END_IF;&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
					ELSE&#xD;
						AccessGranted := TRUE;&#xD;
					END_IF;&#xD;
				&#xD;
				&#xD;
					IF Qty = 0 or (Address &lt; LOWER_BOUND(HoldingRegisters, 1) OR (Address+ Qty) &gt; UPPER_BOUND(HoldingRegisters, 1)) OR NOT AccessGranted THEN 													// wrong quantity&#xD;
						SendDat[1]:=INT_TO_BYTE(INT#16#80 + Funct_Code);&#xD;
						SendDat[2]:=02;&#xD;
						Send_Size:=	3;&#xD;
&#xD;
					ELSE	&#xD;
						idxByte	 := 3;											// initialize index&#xD;
						FOR j:= 1 TO Qty DO																	// add register in the send request&#xD;
							ToAryByte(HoldingRegisters[Address-1 + j],_HIGH_LOW,SendDat[idxByte]);&#xD;
							idxByte									:=idxByte + 2;&#xD;
						END_FOR;&#xD;
		&#xD;
						SendDat[2]:= 	UINT_TO_BYTE(Qty*2);&#xD;
						Send_Size :=			Qty*2 + 3;&#xD;
					END_IF;&#xD;
				&#xD;
&#xD;
			4:  // Read Input Registers	Fn04&#xD;
					IF UseAccesslist THEN&#xD;
						AccessGranted := FALSE;&#xD;
						FOR j := LOWER_BOUND(AccessList, 1) TO UPPER_BOUND(AccessList, 1) DO&#xD;
							IF AccessList[j].RegisterType = eRegisterType#InputRegister THEN&#xD;
								IF AccessList[j].AccessType = eAccess#R OR AccessList[j].AccessType = eAccess#RW THEN&#xD;
									IF  DINT_TO_UDINT(Address) &gt;= AccessList[j].AddressArea.StartAddress AND (DINT_TO_UINT(Address) + Qty) &lt;= (AccessList[j].AddressArea.StartAddress +AccessList[j].AddressArea.Count) THEN&#xD;
										AccessGranted := TRUE;&#xD;
										EXIT;&#xD;
									END_IF;&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
					ELSE&#xD;
						AccessGranted := TRUE;&#xD;
					END_IF;&#xD;
	&#xD;
					IF Qty = 0 or (Address &lt; LOWER_BOUND(InputRegisters, 1) OR (Address+ Qty) &gt; UPPER_BOUND(InputRegisters, 1)) OR NOT AccessGranted THEN 													// wrong quantity&#xD;
						SendDat[1]:=INT_TO_BYTE(INT#16#80 + Funct_Code);&#xD;
						SendDat[2]:=02;&#xD;
						Send_Size:=	3;&#xD;
&#xD;
					ELSE	&#xD;
						idxByte	 := 3;											// initialize index&#xD;
						FOR j:= 1 TO Qty DO																	// add register in the send request&#xD;
							ToAryByte(InputRegisters[Address-1 + j],_HIGH_LOW,SendDat[idxByte]);&#xD;
							idxByte									:=idxByte + 2;&#xD;
						END_FOR;&#xD;
		&#xD;
						SendDat[2]:= 	UINT_TO_BYTE(Qty*2);&#xD;
						Send_Size :=			Qty*2 + 3;&#xD;
					END_IF;&#xD;
&#xD;
&#xD;
			5:	// Write coil		Fn05&#xD;
			&#xD;
					IF UseAccesslist THEN&#xD;
						AccessGranted := FALSE;&#xD;
						FOR j := LOWER_BOUND(AccessList, 1) TO UPPER_BOUND(AccessList, 1) DO&#xD;
							IF AccessList[j].RegisterType = eRegisterType#Coil THEN&#xD;
								IF AccessList[j].AccessType = eAccess#W OR AccessList[j].AccessType = eAccess#RW THEN&#xD;
									IF  DINT_TO_UDINT(Address) &gt;= AccessList[j].AddressArea.StartAddress AND (DINT_TO_UINT(Address)) &lt;= (AccessList[j].AddressArea.StartAddress + AccessList[j].AddressArea.Count) THEN&#xD;
										AccessGranted := TRUE;&#xD;
										EXIT;&#xD;
									END_IF;&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
					ELSE&#xD;
						AccessGranted := TRUE;&#xD;
					END_IF;&#xD;
					&#xD;
					IF (Address &lt; LOWER_BOUND(Coils, 1) OR (Address &gt; UPPER_BOUND(Coils, 1))) OR NOT AccessGranted THEN&#xD;
						SendDat[1]:=INT_TO_BYTE(INT#16#80 + Funct_Code);&#xD;
						SendDat[2]:=02;&#xD;
						Send_Size:=	3;&#xD;
					ELSE&#xD;
						IF RcvDat[4]=BYTE#16#FF THEN &#xD;
							Coils[Address]:=	TRUE;&#xD;
						ELSIF RcvDat[4]=BYTE#00 THEN&#xD;
							Coils[Address]:=	FALSE;&#xD;
						END_IF;&#xD;
						SendDat[2] := RcvDat[2];&#xD;
						SendDat[3] := RcvDat[3];&#xD;
						SendDat[4] := RcvDat[4];&#xD;
						SendDat[5] := RcvDat[5];&#xD;
						Send_Size :=	 UINT#6;&#xD;
					END_IF;&#xD;
					&#xD;
					&#xD;
			6:  //  Write single register Fn06&#xD;
			&#xD;
					IF UseAccesslist THEN&#xD;
						AccessGranted := FALSE;&#xD;
						FOR j := LOWER_BOUND(AccessList, 1) TO UPPER_BOUND(AccessList, 1) DO&#xD;
							IF AccessList[j].RegisterType = eRegisterType#HoldingRegister THEN&#xD;
								IF AccessList[j].AccessType = eAccess#W OR AccessList[j].AccessType = eAccess#RW THEN&#xD;
									IF  DINT_TO_UDINT(Address) &gt;= AccessList[j].AddressArea.StartAddress AND (DINT_TO_UINT(Address)) &lt;= (AccessList[j].AddressArea.StartAddress + AccessList[j].AddressArea.Count) THEN&#xD;
										AccessGranted := TRUE;&#xD;
										EXIT;&#xD;
									END_IF;&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
					ELSE&#xD;
						AccessGranted := TRUE;&#xD;
					END_IF;&#xD;
						&#xD;
					IF (Address &lt; LOWER_BOUND(HoldingRegisters, 1) OR (Address) &gt; UPPER_BOUND(HoldingRegisters, 1)) OR NOT AccessGranted THEN&#xD;
						SendDat[1]:=INT_TO_BYTE(INT#16#80 + Funct_Code);&#xD;
						SendDat[2]:=02;&#xD;
						Send_Size:=	3;&#xD;
					ELSE&#xD;
						AryByteTo(RcvDat[4],UINT#2,_HIGH_LOW,HoldingRegisters[Address]);&#xD;
						&#xD;
						SendDat[2] := RcvDat[2];&#xD;
						SendDat[3] := RcvDat[3];&#xD;
						SendDat[4] := RcvDat[4];&#xD;
						SendDat[5] := RcvDat[5];&#xD;
						Send_Size :=	 UINT#6;&#xD;
					END_IF;&#xD;
&#xD;
&#xD;
			15: // Write multiple coils Fn15&#xD;
			&#xD;
					IF UseAccesslist THEN&#xD;
						AccessGranted := FALSE;&#xD;
						FOR j := LOWER_BOUND(AccessList, 1) TO UPPER_BOUND(AccessList, 1) DO&#xD;
							IF AccessList[j].RegisterType = eRegisterType#Coil THEN&#xD;
								IF AccessList[j].AccessType = eAccess#W OR AccessList[j].AccessType = eAccess#RW THEN&#xD;
									IF  DINT_TO_UDINT(Address) &gt;= AccessList[j].AddressArea.StartAddress AND (DINT_TO_UINT(Address + Qty)) &lt;= (AccessList[j].AddressArea.StartAddress  + AccessList[j].AddressArea.Count) THEN&#xD;
										AccessGranted := TRUE;&#xD;
										EXIT;&#xD;
									END_IF;&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
					ELSE&#xD;
						AccessGranted := TRUE;&#xD;
					END_IF;&#xD;
			&#xD;
					IF Qty = 0 or (Address &lt; LOWER_BOUND(Coils, 1) OR (Address+ Qty) &gt; UPPER_BOUND(Coils, 1)) OR NOT AccessGranted THEN&#xD;
						SendDat[1]:=INT_TO_BYTE(INT#16#80 + Funct_Code);&#xD;
						SendDat[2]:=02;&#xD;
						Send_Size:=	3;&#xD;
					ELSE&#xD;
						&#xD;
						QtyByte := BYTE_TO_UINT(RcvDat[6]);&#xD;
						idxByte := 7;&#xD;
						idxBit := 0;&#xD;
						&#xD;
						FOR j:= Address TO (Address + Qty -1) DO&#xD;
							Coils[j] := TestABit(In := RcvDat[idxByte], Pos := UINT_TO_USINT(idxBit));&#xD;
							Inc(idxBit);&#xD;
							IF idxBit &gt;= 8 THEN&#xD;
								Inc(idxByte);&#xD;
								idxBit := 0;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
						&#xD;
						SendDat[2] := RcvDat[2];&#xD;
						SendDat[3] := RcvDat[3];&#xD;
						SendDat[4] := RcvDat[4];&#xD;
						SendDat[5] := RcvDat[5];&#xD;
						Send_Size :=	 UINT#6;&#xD;
					END_IF;&#xD;
&#xD;
			&#xD;
			16: // Write multiple registers Fn10&#xD;
			&#xD;
					IF UseAccesslist THEN&#xD;
						AccessGranted := FALSE;&#xD;
						FOR j := LOWER_BOUND(AccessList, 1) TO UPPER_BOUND(AccessList, 1) DO&#xD;
							IF AccessList[j].RegisterType = eRegisterType#HoldingRegister THEN&#xD;
								IF AccessList[j].AccessType = eAccess#W OR AccessList[j].AccessType = eAccess#RW THEN&#xD;
									IF  DINT_TO_UDINT(Address) &gt;= AccessList[j].AddressArea.StartAddress AND (DINT_TO_UINT(Address + Qty)) &lt;= (AccessList[j].AddressArea.StartAddress  + AccessList[j].AddressArea.Count) THEN&#xD;
										AccessGranted := TRUE;&#xD;
										EXIT;&#xD;
									END_IF;&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
					ELSE&#xD;
						AccessGranted := TRUE;&#xD;
					END_IF;&#xD;
			&#xD;
					IF Qty = 0 or (Address &lt; LOWER_BOUND(HoldingRegisters, 1) OR (Address+ Qty) &gt; UPPER_BOUND(HoldingRegisters, 1)) OR NOT AccessGranted THEN&#xD;
						SendDat[1]:=INT_TO_BYTE(INT#16#80 + Funct_Code);&#xD;
						SendDat[2]:=02;&#xD;
						Send_Size:=	3;&#xD;
					ELSE&#xD;
						FOR j:= 1 TO (Qty) DO&#xD;
							AryByteTo(RcvDat[5 + j *2], UINT#2, _HIGH_LOW, HoldingRegisters[Address -1 + j]);&#xD;
						END_FOR;&#xD;
						&#xD;
						SendDat[2] := RcvDat[2];&#xD;
						SendDat[3] := RcvDat[3];&#xD;
						SendDat[4] := RcvDat[4];&#xD;
						SendDat[5] := RcvDat[5];&#xD;
						Send_Size :=	 UINT#6;&#xD;
					END_IF;&#xD;
					&#xD;
			23: // Read Write registers Fn17&#xD;
			&#xD;
					AryByteTo(RcvDat[6],UINT#2,_HIGH_LOW,AddressWrite);					// Write address	&#xD;
					AryByteTo(RcvDat[8],UINT#2,_HIGH_LOW,QtyWrite);							// Write quantity&#xD;
					&#xD;
					IF UseAccesslist THEN&#xD;
						AccessGranted := FALSE;&#xD;
						AccessGrantedWrite := FALSE;&#xD;
						FOR j := LOWER_BOUND(AccessList, 1) TO UPPER_BOUND(AccessList, 1) DO&#xD;
							IF AccessList[j].RegisterType = eRegisterType#HoldingRegister THEN&#xD;
								IF AccessList[j].AccessType = eAccess#R OR AccessList[j].AccessType = eAccess#RW THEN&#xD;
									IF  DINT_TO_UDINT(Address) &gt;= AccessList[j].AddressArea.StartAddress AND (DINT_TO_UINT(Address + Qty)) &lt;= (AccessList[j].AddressArea.StartAddress  + AccessList[j].AddressArea.Count) THEN&#xD;
										AccessGranted := TRUE;&#xD;
									END_IF;&#xD;
								END_IF;&#xD;
								IF AccessList[j].AccessType = eAccess#W OR AccessList[j].AccessType = eAccess#RW THEN&#xD;
									IF  DINT_TO_UDINT(AddressWrite) &gt;= AccessList[j].AddressArea.StartAddress AND (DINT_TO_UINT(AddressWrite + QtyWrite)) &lt;= (AccessList[j].AddressArea.StartAddress  + AccessList[j].AddressArea.Count) THEN&#xD;
										AccessGrantedWrite := TRUE;&#xD;
									END_IF;&#xD;
								END_IF;&#xD;
							END_IF;&#xD;
						END_FOR;&#xD;
					ELSE&#xD;
						AccessGranted := TRUE;&#xD;
						AccessGrantedWrite := TRUE;&#xD;
					END_IF;&#xD;
			&#xD;
					IF Qty = 0 or Qty &gt; 125 OR (Address &lt; LOWER_BOUND(HoldingRegisters, 1) OR (Address+ Qty) &gt; UPPER_BOUND(HoldingRegisters, 1)) OR NOT AccessGranted OR NOT AccessGrantedWrite THEN 													// wrong quantity&#xD;
						SendDat[1]:=INT_TO_BYTE(INT#16#80 + Funct_Code);&#xD;
						SendDat[2]:=02;&#xD;
						Send_Size:=	3;&#xD;
					ELSE	&#xD;
						// Write data (Should be performed before read according to spec)&#xD;
						FOR j := 1 TO (QtyWrite) DO&#xD;
							AryByteTo(RcvDat[9 + j *2], UINT#2, _HIGH_LOW, HoldingRegisters[AddressWrite -1 + j]);&#xD;
						END_FOR;&#xD;
						&#xD;
						idxByte	 :=3;																				// initialize index&#xD;
						FOR j := 1 TO Qty DO																// add register in the send request&#xD;
							ToAryByte(HoldingRegisters[Address-1 + j], _HIGH_LOW, SendDat[idxByte]);&#xD;
							idxByte									:=idxByte + 2;&#xD;
						END_FOR;&#xD;
						SendDat[2] := UINT_TO_BYTE(QtyWrite * 2);&#xD;
						Send_Size :=			Qty*2 + 3;&#xD;
					END_IF;&#xD;
	ELSE&#xD;
		SendDat[1]:=INT_TO_BYTE(INT#16#80 + Funct_Code);&#xD;
		SendDat[2]:=01;&#xD;
		Send_Size:=	3;&#xD;
	END_CASE;&#xD;
	State := 200; //Send&#xD;
END_IF;&#xD;
&#xD;
IF State = 200 THEN&#xD;
	CRC_Word := AryCRC16(In := SendDat[0], Size := Send_Size);&#xD;
	ToAryByte(In := CRC_Word, Order := _HIGH_LOW, AryOut := SendDat[Send_Size]);&#xD;
	Send_Size := Send_Size + 2;&#xD;
	iNX_SerialSend(Execute := FALSE, DevicePort := DevicePort, SendDat := SendDat[0], SendSize := Send_Size);&#xD;
	State := 210;&#xD;
END_IF;&#xD;
&#xD;
IF State = 210 THEN&#xD;
	iNX_SerialSend(Execute := TRUE, DevicePort := DevicePort, SendDat := SendDat[0], SendSize := Send_Size);&#xD;
	IF NOT iNX_SerialSend.Busy THEN&#xD;
		IF iNX_SerialSend.Done THEN&#xD;
			State := 30;&#xD;
		END_IF;&#xD;
		&#xD;
		IF iNX_SerialSend.Error THEN&#xD;
			ErrorID := iNX_SerialSend.ErrorID;&#xD;
			State := 300;&#xD;
		END_IF;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
IF State = 300 THEN&#xD;
	IF Error THEN&#xD;
		Error := FALSE;&#xD;
		State := 0;&#xD;
	ELSE&#xD;
		Error := TRUE;&#xD;
	END_IF;&#xD;
END_IF;</Text></StructuredTextModel>